package edu.upc.prop.distance;

import edu.upc.prop.domain.classes.distance.GowerDistance;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class GowerDistanceTest {

    @Test
    public void testDist() {
        GowerDistance gowerDistance = new GowerDistance();

        Vectorizer.Point mockPointA = mock(Vectorizer.Point.class);
        Vectorizer.Point mockPointB = mock(Vectorizer.Point.class);

        double[] valuesA = {0.1, 0.5, 0.8};
        double[] valuesB = {0.3, 0.5, 0.2};
        boolean[] missingA = {false, false, false};
        boolean[] missingB = {false, false, false};

        Vectorizer.Point pointA = new Vectorizer.Point("A", valuesA, missingA);
        Vectorizer.Point pointB = new Vectorizer.Point("B", valuesB, missingB);

        double result = gowerDistance.dist(pointA, pointB);

        assertTrue(result >= 0.0 && result <= 1.0);

        double expected = (Math.abs(0.1-0.3) + Math.abs(0.5-0.5) + Math.abs(0.8-0.2)) / 3.0;
        assertEquals(expected, result, 1e-9);
    }
}package edu.upc.prop.clustering;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.clustering.KMedoids;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;

public class KMedoidsTest {

    private KMedoids kMedoids;
    private List<Vectorizer.Point> mockData;
    private Distance mockDistance;

    @Before
    public void setUp() {
        kMedoids = new KMedoids();

        mockData = new ArrayList<>();
        mockData.add(new Vectorizer.Point("p1", new double[]{1.0, 2.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p2", new double[]{3.0, 4.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p3", new double[]{5.0, 6.0}, new boolean[]{false, false}));

        mockDistance = mock(Distance.class);
    }

    @Test
    public void testRun() {
        ClusterResult result = kMedoids.run(mockData, 2, mockDistance, 10);

        assertNotNull(result);
        assertEquals("k-medoids", result.algorithm());
        assertTrue(result.assignments().size() > 0);
        assertEquals(2, result.representatives().size());
    }
}package edu.upc.prop.clustering;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;

public class ClusterResultTest {

    private ClusterResult clusterResult;
    private Map<String, Integer> testAssignments;
    private List<Vectorizer.Point> testRepresentatives;

    @Before
    public void setUp() {
        testAssignments = new LinkedHashMap<>();
        testAssignments.put("user1", 0);
        testAssignments.put("user2", 1);
        testAssignments.put("user3", 0);

        Vectorizer.Point mockPoint1 = mock(Vectorizer.Point.class);
        Vectorizer.Point mockPoint2 = mock(Vectorizer.Point.class);
        testRepresentatives = Arrays.asList(mockPoint1, mockPoint2);

        clusterResult = new ClusterResult("k-means", testAssignments, testRepresentatives);
    }

    @Test
    public void testAlgorithm() {
        assertEquals("k-means", clusterResult.algorithm());
    }

    @Test
    public void testAssignments() {
        Map<String, Integer> assignments = clusterResult.assignments();
        assertEquals(3, assignments.size());
        assertEquals(Integer.valueOf(0), assignments.get("user1"));
        assertEquals(Integer.valueOf(1), assignments.get("user2"));
        assertEquals(Integer.valueOf(0), assignments.get("user3"));

        try {
            assignments.put("test", 1);
            fail("Falla el put en el map");
        } catch (UnsupportedOperationException e) {}
    }

    @Test
    public void testRepresentatives() {
        List<Vectorizer.Point> representatives = clusterResult.representatives();
        assertEquals(2, representatives.size());
    }
}
package edu.upc.prop.clustering;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.clustering.KMeans;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;

public class KMeansTest {

    private KMeans kMeans;
    private List<Vectorizer.Point> mockData;
    private Distance mockDistance;

    @Before
    public void setUp() {
        kMeans = new KMeans();

        mockData = new ArrayList<>();
        mockData.add(new Vectorizer.Point("p1", new double[]{1.0, 2.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p2", new double[]{3.0, 4.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p3", new double[]{5.0, 6.0}, new boolean[]{false, false}));

        mockDistance = mock(Distance.class);
    }

    @Test
    public void testRun() {
        ClusterResult result = kMeans.run(mockData, 2, mockDistance, false, 10);

        assertNotNull(result);
        assertEquals("k-means", result.algorithm());
        assertTrue(result.assignments().size() > 0);
        assertEquals(2, result.representatives().size());
    }
}package edu.upc.prop.clustering;

import edu.upc.prop.domain.classes.clustering.KMeansPlusPlus;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;

public class KMeansPlusPlusTest {

    private KMeansPlusPlus initializer;
    private List<Vectorizer.Point> mockData;
    private Distance mockDistance;

    @Before
    public void setUp() {
        initializer = new KMeansPlusPlus();

        mockData = new ArrayList<>();
        mockData.add(new Vectorizer.Point("p1", new double[]{1.0, 2.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p2", new double[]{3.0, 4.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p3", new double[]{5.0, 6.0}, new boolean[]{false, false}));
        mockData.add(new Vectorizer.Point("p4", new double[]{7.0, 8.0}, new boolean[]{false, false}));

        mockDistance = mock(Distance.class);
    }

    @Test
    public void testInit() {
        List<Vectorizer.Point> centers = initializer.init(mockData, 3, mockDistance);

        assertNotNull(centers);
        assertEquals(3, centers.size());
        assertTrue(mockData.containsAll(centers));
    }
}package edu.upc.prop.persistence;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.persistence.classes.SurveyRepository;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Collection;

public class SurveyRepositoryTest {

    private SurveyRepository repository;
    private Cuestionario mockCuestionario1;
    private Cuestionario mockCuestionario2;

    @Before
    public void setUp() {
        repository = new SurveyRepository();

        mockCuestionario1 = mock(Cuestionario.class);
        mockCuestionario2 = mock(Cuestionario.class);

        when(mockCuestionario1.getId()).thenReturn("encuesta1");
        when(mockCuestionario2.getId()).thenReturn("encuesta2");
    }

    @Test
    public void testList() {
        repository.put(mockCuestionario1);
        repository.put(mockCuestionario2);

        Collection<Cuestionario> result = repository.list();
        assertEquals(2, result.size());
    }

    @Test
    public void testCreate() {
        repository.create("nueva_encuesta");

        boolean exists = repository.exists("nueva_encuesta");
        assertTrue(exists);
    }

    @Test
    public void testPut() {
        repository.put(mockCuestionario1);

        Cuestionario result = repository.get("encuesta1");
        assertSame(mockCuestionario1, result);
    }

    @Test
    public void testDelete() {
        repository.put(mockCuestionario1);

        boolean deleted = repository.delete("encuesta1");
        assertTrue(deleted);

        boolean exists = repository.exists("encuesta1");
        assertFalse(exists);
    }

    @Test
    public void testExists() {
        repository.put(mockCuestionario1);

        boolean exists = repository.exists("encuesta1");
        assertTrue(exists);

        boolean notExists = repository.exists("encuesta2");
        assertFalse(notExists);
    }

    @Test
    public void testGet() {
        repository.put(mockCuestionario1);

        Cuestionario result = repository.get("encuesta1");
        assertSame(mockCuestionario1, result);

        Cuestionario nullResult = repository.get("encuesta2");
        assertNull(nullResult);
    }
}package edu.upc.prop.persistence;

import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.persistence.classes.ResponseRepository;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.List;

public class ResponseRepositoryTest {

    private ResponseRepository repository;
    private Respuesta mockRespuesta1;
    private Respuesta mockRespuesta2;

    @Before
    public void setUp() {
        repository = new ResponseRepository();

        mockRespuesta1 = mock(Respuesta.class);
        mockRespuesta2 = mock(Respuesta.class);
    }

    @Test
    public void testAdd() {
        repository.add("encuesta1", mockRespuesta1);

        int size = repository.size("encuesta1");
        assertEquals(1, size);
    }

    @Test
    public void testClear() {
        repository.add("encuesta1", mockRespuesta1);
        repository.clear("encuesta1");

        int size = repository.size("encuesta1");
        assertEquals(0, size);
    }

    @Test
    public void testSize() {
        repository.add("encuesta1", mockRespuesta1);
        repository.add("encuesta1", mockRespuesta2);

        int size = repository.size("encuesta1");
        assertEquals(2, size);
    }

    @Test
    public void testAll() {
        repository.add("encuesta1", mockRespuesta1);
        repository.add("encuesta1", mockRespuesta2);

        List<Respuesta> respuestas = repository.all("encuesta1");
        assertEquals(2, respuestas.size());
    }

    @Test
    public void testRemoveById() {
        when(mockRespuesta1.getIdParticipante()).thenReturn("user1");
        repository.add("encuesta1", mockRespuesta1);

        boolean removed = repository.removeById("encuesta1", "user1");
        assertTrue(removed);
    }

    //Para removeQuestion no es pot fer test, ja que no retorna res
}package edu.upc.prop.model;

import edu.upc.prop.domain.classes.model.*;
import org.junit.Test;
import static org.junit.Assert.*;

import java.util.Map;
import java.util.Arrays;
import java.util.List;

public class RespuestaTest {

    @Test
    public void testGetIdParticipante() {
        Respuesta respuesta = new Respuesta("user123");
        String result = respuesta.getIdParticipante();
        assertEquals("user123", result);
    }

    @Test
    public void testGetValores() {
        Respuesta respuesta = new Respuesta("user123");
        Map<String, ValorRespuesta> result = respuesta.getValores();

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testPut() {
        Respuesta respuesta = new Respuesta("user123");

        // 1. Respuesta Textual
        ValorRespuestaTextual valTextual = new ValorRespuestaTextual("Texto de prueba");
        respuesta.put("pregunta1_texto", valTextual);

        // 2. Respuesta Numérica
        ValorRespuestaNumerica valNumerico = new ValorRespuestaNumerica(42.5);
        respuesta.put("pregunta2_num", valNumerico);

        // 3. Respuesta Opción Única (asumiendo que guarda el índice de la opción: 1)
        ValorRespuestaOpcionUnica valUnica = new ValorRespuestaOpcionUnica(1);
        respuesta.put("pregunta3_unica", valUnica);

        // 4. Respuesta Opción Múltiple (asumiendo que guarda una lista de índices: [0, 2])
        List<Integer> indices = Arrays.asList(0, 2);
        ValorRespuestaOpcionMultiple valMultiple = new ValorRespuestaOpcionMultiple(indices);
        respuesta.put("pregunta4_multiple", valMultiple);

        Map<String, ValorRespuesta> valores = respuesta.getValores();
        assertEquals(4, valores.size());

        // Aserciones para verificar que los tipos se guardaron correctamente

        // Pregunta 1: Texto
        assertTrue(valores.get("pregunta1_texto") instanceof ValorRespuestaTextual);
        // Opcional: Verificar el valor real casteando el objeto
        assertEquals("Texto de prueba", ((ValorRespuestaTextual) valores.get("pregunta1_texto")).getValor());

        // Pregunta 2: Numérica
        assertTrue(valores.get("pregunta2_num") instanceof ValorRespuestaNumerica);
        assertEquals(42.5, ((ValorRespuestaNumerica) valores.get("pregunta2_num")).getValor(), 0.001);

        // Pregunta 3: Opción Única
        assertTrue(valores.get("pregunta3_unica") instanceof ValorRespuestaOpcionUnica);
        assertEquals(1, ((ValorRespuestaOpcionUnica) valores.get("pregunta3_unica")).getIndiceSeleccionado());

        // Pregunta 4: Opción Múltiple
        assertTrue(valores.get("pregunta4_multiple") instanceof ValorRespuestaOpcionMultiple);
        assertEquals(indices, ((ValorRespuestaOpcionMultiple) valores.get("pregunta4_multiple")).getIndicesSeleccionados());
    }

    @Test
    public void testRemovePregunta() {
        Respuesta respuesta = new Respuesta("user123");
        ValorRespuestaTextual val1 = new ValorRespuestaTextual("valor1");
        ValorRespuestaNumerica val2 = new ValorRespuestaNumerica(99);

        respuesta.put("pregunta1", val1);
        respuesta.put("pregunta2", val2);

        respuesta.removePregunta("pregunta1");

        Map<String, ValorRespuesta> valores = respuesta.getValores();
        assertEquals(1, valores.size());
        assertFalse(valores.containsKey("pregunta1"));
        assertTrue(valores.containsKey("pregunta2"));
    }
}package edu.upc.prop.model;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;

import java.util.*;

public class CuestionarioTest {

    private Cuestionario cuestionario;
    private Pregunta pregunta1;
    private Pregunta pregunta2;

    @Before
    public void setUp() {
        cuestionario = new Cuestionario("test-id");

        List<String> opciones = Arrays.asList("op1", "op2", "op3");
        pregunta1 = new Pregunta("p1", "Enunciado 1", TipoPregunta.OPCION_UNICA, opciones, 1);
        pregunta2 = new Pregunta("p2", "Enunciado 2", TipoPregunta.OPCION_MULTIPLE, opciones, 3);
    }

    @Test
    public void testGetId() {
        String result = cuestionario.getId();
        assertEquals("test-id", result);
    }

    @Test
    public void testGetPreguntas() {
        List<Pregunta> result = cuestionario.getPreguntas();
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testExistsPregunta() {
        boolean result = cuestionario.existsPregunta("p1");
        assertFalse(result);
    }

    @Test
    public void testAddPregunta() {
        cuestionario.addPregunta(pregunta1);

        assertTrue(cuestionario.existsPregunta("p1"));
        assertEquals(1, cuestionario.getPreguntas().size());
    }

    @Test
    public void testGetPregunta() {
        cuestionario.addPregunta(pregunta1);

        Pregunta result = cuestionario.getPregunta("p1");
        assertSame(pregunta1, result);
    }

    @Test
    public void testEliminarPregunta() {
        cuestionario.addPregunta(pregunta1);

        boolean result = cuestionario.eliminarPregunta("p1");
        assertTrue(result);
        assertFalse(cuestionario.existsPregunta("p1"));
    }

    @Test
    public void testReemplazarPregunta() {
        cuestionario.addPregunta(pregunta1);
        boolean result = cuestionario.reemplazarPregunta("p1", pregunta2);

        assertTrue(result);
        assertSame(pregunta2, cuestionario.getPregunta("p1"));
    }
}package edu.upc.prop.model;

import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import org.junit.Test;
import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.List;

public class PreguntaTest {

    @Test
    public void testGetId() {
        List<String> opciones = Arrays.asList("Sí", "No");
        Pregunta pregunta = new Pregunta("p1", "¿Estas leyendo esto? Tengo hambre, voy a cenar", TipoPregunta.OPCION_UNICA, opciones, 1);

        String result = pregunta.getId();
        assertEquals("p1", result);
    }

    @Test
    public void testGetEnunciado() {
        List<String> opciones = Arrays.asList("Sí", "No");
        Pregunta pregunta = new Pregunta("p1", "¿Sigues leyendo esto? La verdad no se si hacer mas easter eggs de estos por si repercute negativamente en la nota, espero que no xd, por si acaso voy a dejar de hacerlos (de momento :0)", TipoPregunta.OPCION_UNICA, opciones, 1);

        String result = pregunta.getEnunciado();
        assertEquals("¿Sigues leyendo esto? La verdad no se si hacer mas easter eggs de estos por si repercute negativamente en la nota, espero que no xd, por si acaso voy a dejar de hacerlos (de momento :0)", result);
    }

    @Test
    public void testGetTipo() {
        List<String> opciones = Arrays.asList("Sí", "No");
        Pregunta pregunta = new Pregunta("p1", "¿Te gusta Java?", TipoPregunta.OPCION_UNICA, opciones, 1);

        TipoPregunta result = pregunta.getTipo();
        assertEquals(TipoPregunta.OPCION_UNICA, result);
    }

    @Test
    public void testGetOpciones() {
        List<String> opciones = Arrays.asList("Opción A", "Opción B", "Opción C");
        Pregunta pregunta = new Pregunta("p1", "Selecciona una opción", TipoPregunta.OPCION_MULTIPLE, opciones, 2);

        List<String> result = pregunta.getOpciones();
        assertNotNull(result);
        assertEquals(3, result.size());
        assertEquals("Opción A", result.get(0));
        assertEquals("Opción B", result.get(1));
        assertEquals("Opción C", result.get(2));
    }

    @Test
    public void testGetMaxSeleccion() {
        List<String> opciones = Arrays.asList("A", "B", "C", "D");
        Pregunta pregunta = new Pregunta("p1", "Selecciona máximo 2", TipoPregunta.OPCION_MULTIPLE, opciones, 2);

        int result = pregunta.getMaxSeleccion();
        assertEquals(2, result);
    }
}package edu.upc.prop.controllers;

import edu.upc.prop.persistence.controllers.CtrlPersistencia;
import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Usuario;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Arrays;
import java.util.Collection;

public class CtrlEncuestaTest {

    private CtrlDominio ctrlDominio;
    private CtrlPersistencia ctrlPersistencia;
    private Cuestionario mockCuestionario;
    private Pregunta mockPregunta;
    private Usuario mockUsuario;

    @Before
    public void setUp() {
        ctrlPersistencia = mock(CtrlPersistencia.class);
        ctrlDominio = new CtrlDominio(ctrlPersistencia);
        mockCuestionario = mock(Cuestionario.class);
        mockPregunta = mock(Pregunta.class);
        mockUsuario = mock(Usuario.class);

        when(ctrlPersistencia.Uexists("user@test.com")).thenReturn(true);
        when(ctrlPersistencia.Uget("user@test.com")).thenReturn(mockUsuario);
        when(mockUsuario.checkPassword("1234")).thenReturn(true);
        when(mockUsuario.getEmail()).thenReturn("user@test.com");

        boolean logged = ctrlDominio.login("user@test.com", "1234");
        assertTrue("El login de prueba deberia funcionar", logged);
    }

    @Test
    public void testCrear() {
        when(ctrlPersistencia.Eget("encuesta1")).thenReturn(mockCuestionario);

        ctrlDominio.crear("encuesta1");

        verify(ctrlPersistencia).Ecreate("encuesta1");
        verify(mockCuestionario).setOwner("user@test.com");
        verify(ctrlPersistencia).Eput(mockCuestionario);
    }

    @Test
    public void testObtener() {
        when(ctrlPersistencia.Eget("encuesta1")).thenReturn(mockCuestionario);

        Cuestionario resultado = ctrlDominio.obtener("encuesta1");

        assertSame(mockCuestionario, resultado);
    }

    @Test
    public void testListar() {
        Collection<Cuestionario> encuestasMock = Arrays.asList(mockCuestionario);
        when(ctrlPersistencia.Elist()).thenReturn(encuestasMock);

        Collection<Cuestionario> resultado = ctrlDominio.listar();

        assertEquals(1, resultado.size());
        assertTrue(resultado.contains(mockCuestionario));
    }

    @Test
    public void testGuardar() {
        when(mockCuestionario.getOwner()).thenReturn(null);

        ctrlDominio.guardar(mockCuestionario);

        verify(ctrlPersistencia).Eput(mockCuestionario);
    }

    @Test
    public void testEliminar() {
        when(ctrlPersistencia.Eget("encuesta1")).thenReturn(mockCuestionario);
        when(mockCuestionario.getOwner()).thenReturn("user@test.com");
        when(ctrlPersistencia.Edelete("encuesta1")).thenReturn(true);

        boolean eliminado = ctrlDominio.eliminar("encuesta1");

        assertTrue(eliminado);
    }

    @Test
    public void testExiste() {
        when(ctrlPersistencia.Eexists("encuesta1")).thenReturn(true);

        boolean existe = ctrlDominio.existe("encuesta1");

        assertTrue(existe);
    }

    @Test
    public void testAgregarPregunta() {
        when(ctrlPersistencia.Eget("encuesta1")).thenReturn(mockCuestionario);
        when(mockCuestionario.getOwner()).thenReturn("user@test.com");

        ctrlDominio.agregarPregunta("encuesta1", mockPregunta);

        verify(mockCuestionario).addPregunta(mockPregunta);
        verify(ctrlPersistencia).Eput(mockCuestionario);
    }

    @Test
    public void testEliminarPregunta() {
        when(ctrlPersistencia.Eget("encuesta1")).thenReturn(mockCuestionario);
        when(mockCuestionario.getOwner()).thenReturn("user@test.com");
        when(mockCuestionario.eliminarPregunta("pregunta1")).thenReturn(true);

        boolean eliminado = ctrlDominio.eliminarPregunta("encuesta1", "pregunta1");

        assertTrue(eliminado);
        verify(ctrlPersistencia).Eput(mockCuestionario);
    }
}package edu.upc.prop.controllers;

import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Arrays;
import java.util.List;

public class CtrlRespuestaTest {

    private CtrlDominio ctrlDominio;
    private CtrlPersistencia ctrlPersistencia;
    private Respuesta mockRespuesta1;
    private Respuesta mockRespuesta2;

    @Before
    public void setUp() {
        ctrlPersistencia = mock(CtrlPersistencia.class);
        ctrlDominio = new CtrlDominio(ctrlPersistencia);
        mockRespuesta1 = mock(Respuesta.class);
        mockRespuesta2 = mock(Respuesta.class);
    }

    @Test
    public void testAgregar() {
        ctrlDominio.agregar("encuesta1", mockRespuesta1);

        verify(ctrlPersistencia).Radd("encuesta1", mockRespuesta1);
    }

    @Test
    public void testListar() {
        List<Respuesta> respuestasMock = Arrays.asList(mockRespuesta1, mockRespuesta2);
        when(ctrlPersistencia.Rall("encuesta1")).thenReturn(respuestasMock);

        List<Respuesta> resultado = ctrlDominio.listarRespuestas("encuesta1");

        assertEquals(2, resultado.size());
        assertSame(mockRespuesta1, resultado.get(0));
        assertSame(mockRespuesta2, resultado.get(1));
    }

    @Test
    public void testEliminarTodas() {
        ctrlDominio.eliminarTodas("encuesta1");
        verify(ctrlPersistencia).Rclear("encuesta1");
    }

    @Test
    public void testGetSize() {
        when(ctrlPersistencia.Rsize("encuesta1")).thenReturn(5);

        int size = ctrlDominio.getSize("encuesta1");

        assertEquals(5, size);
    }

    @Test
    public void testEliminarPorParticipante() {
        when(ctrlPersistencia.RremoveById("encuesta1", "user1")).thenReturn(true);

        boolean eliminado = ctrlDominio.eliminarPorParticipante("encuesta1", "user1");

        assertTrue(eliminado);
    }

    @Test
    public void testEliminarPregunta() {
        ctrlDominio.eliminarPreguntaR("encuesta1", "pregunta1");

        verify(ctrlPersistencia).RremoveQuestion("encuesta1", "pregunta1");
    }
}package edu.upc.prop.vector;

import edu.upc.prop.domain.classes.vector.VectorSchema;
import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.List;

public class VectorSchemaTest {

    private VectorSchema vectorSchema;

    @Before
    public void setUp() {
        vectorSchema = new VectorSchema();
    }

    @Test
    public void testSetOneHot() {
        List<String> opciones = Arrays.asList("rojo", "azul", "verde");

        vectorSchema.setOneHot("color", opciones);

        List<String> resultado = vectorSchema.getOptions("color");
        assertEquals(3, resultado.size());
        assertEquals("rojo", resultado.get(0));
        assertEquals("azul", resultado.get(1));
        assertEquals("verde", resultado.get(2));
    }

    @Test
    public void testSetNumericRange() {
        vectorSchema.setNumericRange("edad", 18.0, 65.0);

        double[] rango = vectorSchema.getRange("edad");
        assertNotNull(rango);
        assertEquals(18.0, rango[0], 0.001);
        assertEquals(65.0, rango[1], 0.001);
    }

    @Test
    public void testGetOptions() {
        List<String> opciones = Arrays.asList("si", "no");
        vectorSchema.setOneHot("pregunta1", opciones);

        List<String> resultado = vectorSchema.getOptions("pregunta1");
        assertEquals(2, resultado.size());
        assertEquals("si", resultado.get(0));
        assertEquals("no", resultado.get(1));

        resultado = vectorSchema.getOptions("pregunta345");
        assertNotNull(resultado); //getOrdefault siempre devuelve una lista, aunque esté vacía
        assertTrue(resultado.isEmpty());
    }

    @Test
    public void testGetRange() {
        vectorSchema.setNumericRange("altura", 150.0, 200.0);

        double[] rango = vectorSchema.getRange("altura");
        assertNotNull(rango);
        assertEquals(150.0, rango[0], 0.001);
        assertEquals(200.0, rango[1], 0.001);

        rango = vectorSchema.getRange("pregunta23");
        assertNull(rango);
    }

    @Test
    public void testSetDimensions() {
        vectorSchema.setDimensions(10);

        int dimensiones = vectorSchema.getDimensions();
        assertEquals(10, dimensiones);
    }
}package edu.upc.prop.drivers;

import edu.upc.prop.persistence.controllers.CtrlPersistencia;
import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.util.ConsoleIO;


public class Driver {
    private static final ConsoleIO io = new ConsoleIO();


    @SuppressWarnings("unused")
    public static void main(String[] args) {
        //Si la primera línea de la entrada es "input", se activa el modo automático
        String m = io.prompt("");
        // Referenciamos `args` explícitamente para evitar advertencias de parámetro no usado
        if (args != null && args.length > 0) {
            // no hacemos nada ruidoso: solo leemos la longitud para marcar uso
            int _unused = args.length;
        }
        ConsoleIO.Modo modo;
        if (m.equals("input")) {
            modo = ConsoleIO.Modo.AUTOMATICO;
        }
        else modo = ConsoleIO.Modo.MANUAL;
        io.setModo(modo);

        //Repositorios
        CtrlPersistencia ctrlPersistencia = new CtrlPersistencia();
        CtrlDominio ctrlDominio = new CtrlDominio(ctrlPersistencia);

        // Bucle externo: permite volver al menú de autenticación desde el menú principal
        while (true) {
            //Autenticación
            boolean autenticado = false;
            while (!autenticado) {
                if (io.getModo() == ConsoleIO.Modo.MANUAL) {
                    System.out.println("\n=== Autenticación ===");
                    System.out.println("1) Iniciar sesión");
                    System.out.println("2) Registrarse");
                    System.out.println("0) Salir");
                }

                String opt = io.prompt("Opcion");

                switch (opt) {
                    case "1" -> {
                        String email = io.prompt("Email");
                        String pass = io.prompt("Contraseña");
                        if (ctrlDominio.login(email, pass)) {
                            System.out.println("Inicio de sesión correcto. Bienvenido, " + ctrlDominio.getUsuarioLogueadoNombre() + "!");
                            autenticado = true;
                        } else {
                            System.out.println("Email o contraseña incorrectos.");
                        }
                    }
                    case "2" -> {
                        String email = io.prompt("Email");
                        String nombre = io.prompt("Nombre");
                        String ape = io.prompt("Apellido");
                        String nac = io.prompt("Fecha nacimiento (DD/MM/AAAA)");
                        String pass = io.prompt("Contraseña");
                        try {
                            ctrlDominio.registrarUsuario(email, pass, nombre, ape, nac);
                            System.out.println("Usuario registrado con éxito. Puedes iniciar sesión ahora.");
                        } catch (IllegalArgumentException e) {
                            System.out.println("Error registro: " + e.getMessage());
                        }
                    }
                    case "0" -> {
                        return; // salir del programa
                    }
                    default -> System.out.println("Opcion invalida");
                }
            }


            //Menus
            EncuestaMenu encuestaMenu = new EncuestaMenu(io, ctrlDominio, modo);
            RespuestaMenu respuestaMenu = new RespuestaMenu(io, ctrlDominio, modo);
            ClusteringMenu clusteringMenu = new ClusteringMenu(io, ctrlDominio, modo);
            ExportarImportarMenu exportarImportarMenu = new ExportarImportarMenu(io, ctrlDominio, modo);

            // MENU PRINCIPAL (se mantiene hasta que el usuario decida volver a autenticación o salir)
            menuLoop:
            while (true) {
                if(io.getModo() == ConsoleIO.Modo.MANUAL){
                    System.out.println("\nMENU PRINCIPAL");
                    System.out.println("Encuestas cargadas: " + ctrlDominio.listar().size());
                    System.out.println("1) Encuestas (crear con preguntas, listar, editar, eliminar)");
                    System.out.println("2) Respuestas (por encuesta)");
                    System.out.println("3) Clustering (por encuesta)");
                    System.out.println("4) Importar / Exportar");
                    System.out.println("5) Comparar fichero de entrada con fichero de salida");
                    System.out.println("6) Cerrar sesión");
                    System.out.println("0) Salir");
                }

                String opcion = io.prompt("Opcion");

                try { //Se escoge a qué menú acceder
                    switch (opcion) {
                        case "1" -> encuestaMenu.ejecutar();
                        case "2" -> respuestaMenu.ejecutar();
                        case "3" -> clusteringMenu.ejecutar();
                        case "4" -> exportarImportarMenu.ejecutar();
                        case "5" -> {
                            compararFicheros();
                            return;
                        }
                        case "6" -> {
                            // Volver al menú de autenticación: hacemos logout y rompemos el bucle del menú principal
                            ctrlDominio.logout();
                            break menuLoop;
                        }
                        case "0" -> {
                            return;
                        }
                        default -> System.out.println("Opcion invalida");
                    }
                }
                catch (Exception e) {
                    System.out.println("Error inesperado: " + e.getMessage());
                }
            }

            // Si hemos solicitado volver a autenticación, el while externo repetirá el proceso
        }
    }

    private static void compararFicheros() {
        String archivo1 = io.prompt("Ruta del fichero generado por el programa");
        String archivo2 = io.prompt("Ruta del fichero de referencia a comparar");

        java.io.File f1 = new java.io.File(archivo1);
        java.io.File f2 = new java.io.File(archivo2);

        // Si no existen, intentar suponer que están en ./csvFiles/<nombre>
        if (!f1.exists()) {
            java.io.File alt1 = new java.io.File("csvFiles", new java.io.File(archivo1).getName());
            if (alt1.exists()) {
                System.out.println("Usando fichero de proyecto: " + alt1.getPath());
                f1 = alt1;
            } else {
                System.out.println("Fichero no encontrado: " + archivo1);
                return;
            }
        }
        if (!f2.exists()) {
            java.io.File alt2 = new java.io.File("csvFiles", new java.io.File(archivo2).getName());
            if (alt2.exists()) {
                System.out.println("Usando fichero de proyecto: " + alt2.getPath());
                f2 = alt2;
            } else {
                System.out.println("Fichero no encontrado: " + archivo2);
                return;
            }
        }

        try {
            boolean iguales = compararArchivosLineaALinea(f1.getPath(), f2.getPath());
            if (iguales) {
                System.out.println("\nLos ficheros son IGUALES");
            } else {
                System.out.println("\nLos ficheros son DIFERENTES");
            }
        }
        catch (Exception e) {
            System.out.println("Error comparando ficheros: " + e.getMessage());
        }
    }

    private static boolean compararArchivosLineaALinea(String f1, String f2) throws Exception {
        try (java.io.BufferedReader br1 = new java.io.BufferedReader(new java.io.FileReader(f1));
             java.io.BufferedReader br2 = new java.io.BufferedReader(new java.io.FileReader(f2))) {

            String l1, l2;
            int linea = 1;

            while (true) {
                l1 = br1.readLine();
                l2 = br2.readLine();

                if (l1 == null && l2 == null) {
                    return true; // llegaron al final iguales
                }
                if (l1 == null || l2 == null) {
                    System.out.println("\nDiferencia en línea " + linea + ": longitud diferente");
                    return false;
                }
                if (!l1.equals(l2)) {
                    System.out.println("Diferencia en línea " + linea + ":");
                    System.out.println("  Archivo 1: " + l1);
                    System.out.println("  Archivo 2: " + l2);
                    return false;
                }
                linea++;
            }
        }
    }

}
package edu.upc.prop.drivers;

import edu.upc.prop.domain.classes.model.ValorRespuesta;
import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.util.ConsoleIO;
import edu.upc.prop.domain.classes.model.ValorRespuestaNumerica;
import edu.upc.prop.domain.classes.model.ValorRespuestaTextual;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionUnica;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionMultiple;

import java.util.*;

public class RespuestaMenu {

    private final ConsoleIO io;
    private final CtrlDominio ctrlDominio;
    private final ConsoleIO.Modo modo;

    public RespuestaMenu(ConsoleIO io, CtrlDominio ctrlDominio, ConsoleIO.Modo modo) {
        this.io = io;
        this.ctrlDominio = ctrlDominio;
        this.modo = modo;
    }

    public void ejecutar() {
        Cuestionario en = FuncionesEncuesta.seleccionarEncuesta(io, ctrlDominio);
        if (en == null) return; //La respuesta tiene que pertenecer a una encuesta existente

        while (true) {
            if(modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("\nRespuestas de " + en.getId());
                System.out.println("1) Agregar respuesta");
                System.out.println("2) Listar respuestas");
                System.out.println("3) Eliminar respuesta de un participante");
                System.out.println("4) Eliminar todas las respuestas");
                System.out.println("0) Volver");
            }
            String opcion = io.prompt("Opcion");
            switch (opcion) {
                case "1" -> agregarRespuesta(en);
                case "2" -> listarRespuestas(en);
                case "3" -> {
                    String p = io.prompt("Participante a eliminar");
                    if (p.isBlank()) {
                        System.out.println("Id de participante vacio");
                    }
                    else {
                        if (ctrlDominio.eliminarPorParticipante(en.getId(), p)) {
                            System.out.println("Eliminada respuesta del participante " + p);
                        }
                        else {
                            System.out.println("No encontrada");
                        }

                    }
                }
                case "4" -> {
                    ctrlDominio.eliminarTodas(en.getId());
                    System.out.println("Respuestas borradas de la encuesta: " + en.getId());
                }
                case "0" -> {
                    return;
                }
                default -> System.out.println("Opcion invalida");
            }
        }
    }

    private void agregarRespuesta(Cuestionario en) {
        if (en.getPreguntas().isEmpty()) {
            System.out.println("La encuesta no tiene preguntas");
            return; //No se pueden agregar respuestas a encuestas sin preguntas
        }

        if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Creando nueva respuesta para la encuesta " + en.getId());

        // Obtener el identificador del participante: preferimos usar el email del usuario logueado
        String par = null;
        try {
            par = ctrlDominio.getUsuarioLogueadoEmail();
        } catch (Exception ignored) {
            // Si por alguna razón no está disponible, seguiremos con el fallback
        }

        if (par == null || par.isBlank()) {
            // Fallback al comportamiento anterior: generar id por defecto y preguntar al usuario
            String s = "resp" + (ctrlDominio.getSize(en.getId()) + 1);
            String respuestaPrompt = io.promptDefault("Id de participante", s);
            if (respuestaPrompt == null || respuestaPrompt.isBlank()) par = s;
            else par = respuestaPrompt;
        } else {
            if (modo == ConsoleIO.Modo.MANUAL) System.out.println("Usando participante logueado: " + par);
        }

        Respuesta r = new Respuesta(par);

        for (Pregunta p : en.getPreguntas()) {
            if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Pregunta (" + p.getTipo() + ")");
            if(modo == ConsoleIO.Modo.MANUAL) System.out.println(p.getEnunciado());

            switch (p.getTipo()) {
                case NUMERICA -> {
                    String v = io.prompt("Valor numerico (enter = sin respuesta)");
                    if (!v.isBlank()) {
                        try {
                            double d = Double.parseDouble(v);
                            r.put(p.getId(), new ValorRespuestaNumerica(d));
                        } catch (NumberFormatException e) {
                            if(modo == ConsoleIO.Modo.MANUAL) System.out.println("No es un numero valido, se omite la respuesta");
                        }
                    }
                }
                case TEXTO -> {
                    String v = io.prompt("Texto (enter = sin respuesta)");
                    if (!v.isBlank()) r.put(p.getId(), new ValorRespuestaTextual(v));
                }
                case OPCION_UNICA -> {
                    if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Opciones disponibles: " + p.getOpciones());
                    String v = io.prompt("Escribe una opción tal cual (enter = sin respuesta)");

                    if (!v.isBlank()) {
                        int indice = p.getOpciones().indexOf(v);
                        if (indice != -1 && p.getOpciones().contains(v)) {
                            r.put(p.getId(), new ValorRespuestaOpcionUnica(indice));
                        }
                        else {
                            if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Opción no válida. No se añade respuesta para esta pregunta.");
                        }
                    }
                }
                case OPCION_MULTIPLE -> {
                    if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Opciones disponibles: " + p.getOpciones());
                    if (p.getMaxSeleccion() > 0 && modo == ConsoleIO.Modo.MANUAL) System.out.println("Maximo a seleccionar: " + p.getMaxSeleccion());

                    String v = io.prompt("Selecciona separando con '|' (enter = sin respuesta)");
                    if (!v.isBlank()) {
                        List<String> sel = new ArrayList<>(Arrays.asList(v.split("\\|"))); //opciones seleccionadas
                        sel.replaceAll(String::trim); //eliminar espacios

                        List<Integer> indicesValidos = new ArrayList<>();
                        for (String opcion : sel) {
                            int indice = p.getOpciones().indexOf(opcion);
                            if (indice != -1) {
                                indicesValidos.add(indice);
                            } else {
                                if(modo == ConsoleIO.Modo.MANUAL) System.out.println("La opción '" + opcion + "' no es válida y se descarta.");
                            }
                        }

                        // Verificar que queda al menos una válida
                        if (indicesValidos.isEmpty()) {
                            if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Ninguna opción ingresada es válida. No se añade respuesta a esta pregunta.");
                            // No usamos break porque queremos continuar al siguiente ciclo del for.
                        } else {
                            //Se seleccionan mas opciones del maximo
                            if (p.getMaxSeleccion() > 0 && indicesValidos.size() > p.getMaxSeleccion()) {
                                if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Has seleccionado mas de " + p.getMaxSeleccion() + "opciones, se guardan las primeras");
                                indicesValidos = indicesValidos.subList(0, p.getMaxSeleccion());
                            }
                            r.put(p.getId(), new ValorRespuestaOpcionMultiple(indicesValidos));
                        }
                    }
                }
            }
        }

        ctrlDominio.agregar(en.getId(), r);
        System.out.println("Respuesta agregada a la encuesta '" + en.getId() + "' con id de participante: " + par);
    }

    private void listarRespuestas(Cuestionario en) {
        List<Respuesta> resp = ctrlDominio.listarRespuestas(en.getId());
        if (resp.isEmpty()) {
            System.out.println("No hay respuestas para esta encuesta");
            return;
        }

        System.out.println("Respuestas de la encuesta " + en.getId() + ": " + resp.size());

        StringBuilder header = new StringBuilder("idParticipante");
        for (Pregunta p : en.getPreguntas()) {
            header.append(",").append(p.getId());
        }
        System.out.println(header);

        for (Respuesta r : resp) {
            StringBuilder fila = new StringBuilder();
            fila.append(r.getIdParticipante());
            for (Pregunta p : en.getPreguntas()) {
                fila.append(",");
                ValorRespuesta vr = r.getValores().get(p.getId());
                if (vr != null) {
                    fila.append(vr.getValorNormalizado());
                } // si es null, dejamos la celda vacía (ya se añadió la coma)
            }
            System.out.println(fila);
        }

    }


}
package edu.upc.prop.drivers;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.distance.GowerDistance;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.impexp.CsvClusterExporter;
import edu.upc.prop.domain.classes.util.ConsoleIO;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import edu.upc.prop.domain.classes.evaluation.ClusteringAccuracy;

import java.nio.file.Path;
import java.util.*;

public class ClusteringMenu {

    private final ConsoleIO io;
    private final CtrlDominio ctrlDominio;
    private final ConsoleIO.Modo modo;

    public ClusteringMenu(ConsoleIO io, CtrlDominio ctrlDominio, ConsoleIO.Modo modo) {
        this.io = io;
        this.ctrlDominio = ctrlDominio;
        this.modo = modo;
    }

    public void ejecutar() {
        Cuestionario c = FuncionesEncuesta.seleccionarEncuesta(io, ctrlDominio);
        if (c == null) return;

        while (true) {
            if (modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("\nClustering sobre " + c.getId());
                System.out.println("Respuestas: " + ctrlDominio.getSize(c.getId()));
                System.out.println("1) k-means (random init)");
                System.out.println("2) k-means++ (init)");
                System.out.println("3) k-medoids (PAM)");
                System.out.println("4) Ver ultimo resultado");
                System.out.println("5) Exportar ultimo resultado a CSV");
                System.out.println("6) Calcular accuracy respecto a CSV de etiquetas");
                System.out.println("0) Volver");
            }
            String op = io.prompt("Opcion");
            switch (op) {
                case "1" -> ejecutarKMeans(c, false);
                case "2" -> ejecutarKMeans(c, true);
                case "3" -> ejecutarKMedoids(c);
                case "4" -> verUltimoResultado();
                case "5" -> exportarUltimoResultado();
                case "6" -> calcularAccuracy();
                case "0" -> {
                    return;
                }
                default -> System.out.println("Opcion invalida");
            }
        }

    }

    private void verUltimoResultado() {
        ClusterResult res = ctrlDominio.getUltimoResultado();
        String id = ctrlDominio.getUltimoResultadoEncuestaId();

        if (res == null || id == null) {
            System.out.println("Aun no hay resultado.");
            return;
        }

        Cuestionario cc = ctrlDominio.getEncuesta(id);
        if (cc == null) {
            System.out.println("La encuesta asociada al ultimo resultado ya no existe");
            return;
        } else {
            imprimirResumenDetallado(res, cc);
            long ultimoTiempoMs = ctrlDominio.getUltimoTiempoMs();
            double ultimoSse = ctrlDominio.getUltimoSse();
            double ultimoSilhouette = ctrlDominio.getUltimoSilhouette();

            if (!Double.isNaN(ultimoSse) || !Double.isNaN(ultimoSilhouette) || ultimoTiempoMs >= 0) {
                if(modo == ConsoleIO.Modo.MANUAL) System.out.println("Metricas del ultimo resultado:");
                if (!Double.isNaN(ultimoSse)) {
                    if(modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US, "  SSE: %.4f%n", ultimoSse);
                }
                if (!Double.isNaN(ultimoSilhouette)) {
                    if(modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US, "  Silhouette: %.4f%n", ultimoSilhouette);
                }
                if (ultimoTiempoMs >= 0) {
                    if(modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US, "  Tiempo: %.3f segundos (%d ms)%n",
                            ultimoTiempoMs / 1000.0, ultimoTiempoMs);
                }
            }
        }
    }

    private void ejecutarKMeans(Cuestionario c, boolean kpp) {
        int n = ctrlDominio.numRespuestas(c.getId());
        if (n == 0) {
            System.out.println("No hay respuestas. No se puede hacer clustering.");
            return;
        }
        int k = io.promptInt("k (1.." + n + ")");
        if (k <= 0 || k > n) {
            System.out.println("Valor k invalido. Debe estar entre 1 y " + n);
            return;
        }

        ClusterResult res;
        try {
            res = ctrlDominio.ejecutarKMeans(c, k, kpp);
        } catch (IllegalStateException e) {
            System.out.println("Error al vectorizar respuestas: " + e.getMessage());
            return;
        }

        if (modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US, "Tiempo de clustering (k-means%s): %.3f segundos (%d ms)%n", kpp ? "++" : "", ctrlDominio.getUltimoTiempoMs() / 1000.0, ctrlDominio.getUltimoTiempoMs());


        imprimirResumenDetallado(res, c);
        System.out.printf(Locale.US, "Metricas -> SSE: %.4f | Silhouette: %.4f%n", ctrlDominio.getUltimoSse(), ctrlDominio.getUltimoSilhouette());

    }

    private void ejecutarKMedoids(Cuestionario c) {
        int n = ctrlDominio.numRespuestas(c.getId());
        if (n == 0) {
            System.out.println("No hay respuestas. No se puede hacer clustering.");
            return;
        }
        int k = io.promptInt("k (1.." + n + ")");
        if (k <= 0 || k > n) {
            System.out.println("Valor k invalido. Debe estar entre 1 y " + n);
            return;
        }

        ClusterResult res;
        try {
            res = ctrlDominio.ejecutarKMedoids(c, k);
        } catch (IllegalStateException e) {
            System.out.println("Error al vectorizar respuestas: " + e.getMessage());
            return;
        }


        if (modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US, "Tiempo de clustering (k-medoids): %.3f segundos (%d ms)%n", ctrlDominio.getUltimoTiempoMs() / 1000.0, ctrlDominio.getUltimoTiempoMs());

        imprimirResumenDetallado(res, c);
        System.out.printf(Locale.US, "Metricas -> SSE: %.4f | Silhouette: %.4f%n", ctrlDominio.getUltimoSse(), ctrlDominio.getUltimoSilhouette());
    }

    private void exportarUltimoResultado() {
        ClusterResult res = ctrlDominio.getUltimoResultado();
        String id = ctrlDominio.getUltimoResultadoEncuestaId();

        if (res == null || id == null) {
            System.out.println("Aun no hay resultado");
            return;
        }

        String ruta = io.prompt("Ruta CSV de salida (ej. clusters.csv)");
        if (ruta.isBlank()) {
            System.out.println("Ruta vacia, no se exporta nada.");
            return;
        }

        Path out = Path.of(ruta);
        CsvClusterExporter exporter = new CsvClusterExporter();

        Cuestionario c = ctrlDominio.getEncuesta(id);
        if (c == null) {
            System.out.println("La encuesta asociada al ultimo resultado ya no existe");
            return;
        }
        List<Respuesta> listaRespuestas = ctrlDominio.listarRespuestas(id);

        try {
            exporter.exportClusterResult(
                    out,
                    res,
                    ctrlDominio.getUltimoSse(),
                    ctrlDominio.getUltimoSilhouette(),
                    ctrlDominio.getUltimoTiempoMs(),
                    c,
                    listaRespuestas
            );
            System.out.println("Resultado exportado a " + out);
        } catch (Exception e) {
            System.out.println("No se pudieron exportar los resultados: " + e.getMessage());
        }
    }

    private void calcularAccuracy() {
        ClusterResult res = ctrlDominio.getUltimoResultado();
        if (res == null) {
            System.out.println("Aun no hay resultado de clustering. Ejecuta primero k-means / k-means++ / k-medoids");
            return;
        }

        String ruta = io.prompt("Ruta del CSV de etiquetas (ej. loan-train.csv)");
        if (ruta.isBlank()) {
            System.out.println("Ruta vacia, no se calcula accuracy.");
            return;
        }

        try {
            double acc = ClusteringAccuracy.accuracyFromCsv(res, Path.of(ruta));
            if(modo == ConsoleIO.Modo.MANUAL) System.out.printf(Locale.US,
                    "Mejor accuracy respecto a %s: %.2f%%%n",
                    Path.of(ruta),
                    acc * 100.0
            );
        } catch (Exception e) {
            System.out.println("Error calculando accuracy: " + e.getMessage());
        }
    }

    private void imprimirResumenDetallado(ClusterResult res, Cuestionario c) {
        if (res == null) {
            System.out.println("Aun no hay resultado.");
            return;
        }
        if (ctrlDominio.numRespuestas(c.getId()) == 0) {
            System.out.println("No hay respuestas para mostrar resumen.");
            return;
        }

        System.out.println("Algoritmo: " + res.algorithm());
        if (modo == ConsoleIO.Modo.MANUAL) {
            System.out.println("Asignaciones:");
            res.assignments().forEach((pid, cid) -> System.out.println("  " + pid + " -> " + cid));
        }

        Distance dist = new GowerDistance();
        List<Vectorizer.Point> datos;
        try {
            datos = ctrlDominio.vectorizar(c);
        } catch (IllegalStateException e) {
            System.out.println("Error al vectorizar para el resumen: " + e.getMessage());
            return;
        }

        Map<String, Vectorizer.Point> byId = new HashMap<>();
        for (var p : datos) byId.put(p.id(), p);

        Map<Integer, List<Vectorizer.Point>> grupos = new HashMap<>();
        for (var e : res.assignments().entrySet()) {
            grupos.computeIfAbsent(e.getValue(), k -> new ArrayList<>()).add(byId.get(e.getKey()));
        }

        System.out.println("Representantes por cluster:");
        for (int cid = 0; cid < res.representatives().size(); cid++) {
            var rep = res.representatives().get(cid);
            var miembros = grupos.getOrDefault(cid, List.of());

            if (rep.id().startsWith("centro_")) {
                double best = Double.POSITIVE_INFINITY;
                String bestId = "(ninguno)";
                for (var p : miembros) {
                    double d = dist.dist(p, rep);
                    if (d < best) {
                        best = d;
                        bestId = p.id();
                    }
                }
                double representanteDist = (miembros.isEmpty() ? 0.0 : best);
                System.out.printf("  Cluster %d -> punto mas cercano al centroide: %s (dist=%.4f)%n",
                        cid, bestId, representanteDist);
            } else {
                System.out.printf("  Cluster %d -> medoid (dato real): %s%n", cid, rep.id());
            }
        }
    }
}
package edu.upc.prop.drivers;

import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.util.ConsoleIO;

import java.util.*;

public class EncuestaMenu {
    private final ConsoleIO io;
    private final CtrlDominio ctrlDominio;
    private final ConsoleIO.Modo modo;

    public EncuestaMenu(ConsoleIO io, CtrlDominio ctrlDominio, ConsoleIO.Modo modo) {
        this.io = io;
        this.modo = modo;
        this.ctrlDominio = ctrlDominio;
    }

    public void ejecutar() {
        while (true) {
            if(modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("\nEncuestas");
                System.out.println("1) Crear encuesta");
                System.out.println("2) Listar encuestas");
                System.out.println("3) Editar encuesta");
                System.out.println("4) Eliminar encuesta");
                System.out.println("0) Volver");
            }
            String opcion = io.prompt("Opcion");
            switch (opcion) { //Se escoge que hacer con las encuestas
                case "1" -> crearEncuestaConPreguntas();
                case "2" -> listarEncuestas();
                case "3" -> editarEncuesta();
                case "4" -> eliminarEncuesta();
                case "0" -> {
                    return;
                }
                default -> System.out.println("Opcion invalida");
            }
        }
    }

    //Encuestas

    private void crearEncuestaConPreguntas() {
        if (!ctrlDominio.estaLogueado()) {
            System.out.println("Debes iniciar sesión para crear encuestas.");
            return;
        }
        String id = io.prompt("Id de la nueva encuesta");
        if (id.isBlank()) {
            if(modo == ConsoleIO.Modo.MANUAL) System.out.println("El id no puede estar vacio");
            return;
        }
        try {
            ctrlDominio.crear(id); //Se crea encuesta nueva
        }
        catch (Exception e) {
            System.out.println("Error al crear encuesta: " + e.getMessage());
            return;
        }
        Cuestionario en = ctrlDominio.obtener(id); //Se obtiene la encuesta creada
        System.out.println("Encuesta creada: " + id);

        while (true) {
            if(modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("1) Agregar pregunta");
                System.out.println("2) Listar preguntas");
                System.out.println("0) Terminar");
            }
            String opcion = io.prompt("Opcion");
            switch (opcion){ //Se escoge que hacer con las preguntas
                case "1" -> agregarPregunta(en);
                case "2" -> listarPreguntas(en);
                case "0" -> {
                    return;
                }
                default -> System.out.println("Opcion invalida");
            }
        }
    }

    private void listarEncuestas() {
        FuncionesEncuesta.mostrarEncuestasDisponibles(ctrlDominio, io);
    }

    private void editarEncuesta() {
        if (!ctrlDominio.estaLogueado()) {
            System.out.println("Debes iniciar sesión para editar encuestas.");
            return;
        }
        Cuestionario en = FuncionesEncuesta.seleccionarEncuesta(io, ctrlDominio);
        if (en == null) return;

        while (true) {
            if(modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("Editando '" + en.getId());
                System.out.println("1) Listar preguntas");
                System.out.println("2) Agregar pregunta");
                System.out.println("3) Eliminar pregunta");
                System.out.println("0) Volver");
            }
            String op = io.prompt("Opcion");
            switch (op) {
                case "1" -> listarPreguntas(en);
                case "2" -> agregarPregunta(en);
                case "3" -> eliminarPregunta(en);
                case "0" -> {
                    return;
                }
                default -> System.out.println("Opcion invalida");
            }
        }
    }

    private void eliminarEncuesta() {
        if (!ctrlDominio.estaLogueado()) {
            System.out.println("Debes iniciar sesión para eliminar encuestas.");
            return;
        }
        if (!FuncionesEncuesta.mostrarEncuestasDisponibles(ctrlDominio, io)) return; //No hay encuestas

        String id = io.prompt("Id a eliminar");
        if (id.isBlank()) {
            System.out.println("Id vacio, no se elimina nada");
            return;
        }
        if (ctrlDominio.eliminar(id)) {
            ctrlDominio.eliminarTodas(id);
            System.out.println("Encuesta '" + id + "' eliminada y respuestas borradas");
        }
        else {
            System.out.println("No existe encuesta con id '" + id);
        }
    }

    //Preguntas

    private void listarPreguntas(Cuestionario en) {
        if (en.getPreguntas().isEmpty()) {
            System.out.println("No hay preguntas");
            return;
        }

        System.out.println("Listando preguntas de la encuesta '" + en.getId() + "':");
        List<Pregunta> preguntas = en.getPreguntas();
        for (int i = 0; i < preguntas.size(); i++) {
            Pregunta p = preguntas.get(i);
            System.out.println((i+1) + ") " + p.getEnunciado() + " " + p.getTipo());
            if (p.getOpciones() != null && !p.getOpciones().isEmpty()) {
                System.out.print("Opciones: " + p.getOpciones());
                if (p.getTipo() == TipoPregunta.OPCION_MULTIPLE) { //Tienen una seleccion maxima
                    System.out.print(" (max=" + p.getMaxSeleccion() + ")");
                }
                System.out.println();
            }
        }
    }

    private TipoPregunta leerTipoPregunta() {
        String prompt = "Tipo (OPCION_UNICA, OPCION_MULTIPLE, NUMERICA, TEXTO)";
        while (true) {
            String entrada = io.prompt(prompt).trim(); //Se lee el tipo de pregunta
            if (entrada.isEmpty()) {
                System.out.println("Debes indicar un tipo de pregunta");
                continue;
            }
            try {
                String tp = entrada.trim().toUpperCase();
                return TipoPregunta.valueOf(tp); //Tipo existe en enum TipoPregunta
            }
            catch (IllegalArgumentException e) {
                System.out.println("Tipo invalido. Tipos validos: OPCION_UNICA, OPCION_MULTIPLE, NUMERICA, TEXTO");
            }
        }
    }

    private void agregarPregunta(Cuestionario en) {
        String enun = io.prompt("Texto de la pregunta (identificador en el CSV)");
        if (enun.isBlank()) {
            System.out.println("La pregunta no puede estar vacia");
            return;
        }
        if (en.getPregunta(enun) != null) {
            System.out.println("Ya existe una pregunta con ese texto. Usa otro enunciado");
            return;
        }

        TipoPregunta tipo = leerTipoPregunta();
        List<String> opciones = new ArrayList<>();
        int maxSel = 0;

        if (tipo == TipoPregunta.OPCION_UNICA || tipo == TipoPregunta.OPCION_MULTIPLE) {
            String entrada = io.prompt("Opciones separadas por | (ej. Opcion1|Opcion2|Opcion3)");
            if (!entrada.isBlank()) {
                opciones = Arrays.asList(entrada.split("\\|"));
            }
            if (tipo == TipoPregunta.OPCION_MULTIPLE) {
                String ms = io.prompt("Maximo a seleccionar (0 = sin limite)");
                if (!ms.isBlank()) {
                    try {
                        maxSel = Integer.parseInt(ms.trim()); //Se pasa la entrada a entero
                        if (maxSel < 0) {
                            System.out.println("No puede ser negativo, se deja a 0 (sin limite)");
                            maxSel = 0;
                        }
                    }
                    catch (NumberFormatException e) {
                        System.out.println("Valor no valido, se deja a 0 (sin limite)");
                        maxSel = 0;
                    }
                }
            }
        }

        try {
            ctrlDominio.agregarPregunta(en.getId(), new Pregunta(enun, enun, tipo, opciones, maxSel)); //Se agrega la pregunta a la encuesta
            System.out.println("Pregunta agregada");
        }
        catch (IllegalArgumentException e) {
            System.out.println("Error al agregar pregunta: " + e.getMessage());
        }
    }

    private void eliminarPregunta(Cuestionario en) {
        String id = io.prompt("Id de pregunta a eliminar (texto exacto de la pregunta):");
        if (id.isBlank()) {
            System.out.println("Id vacio, no se elimina nada");
            return;
        }
        if (ctrlDominio.eliminarPregunta(en.getId(), id)) {
            ctrlDominio.eliminarPregunta(en.getId(), id);
            System.out.println("Pregunta eliminada.");
        }
        else {
            System.out.println("No existe pregunta con ese id");
        }
    }
}
package edu.upc.prop.drivers;

import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.impexp.CsvSurveyExporter;
import edu.upc.prop.domain.classes.impexp.CsvSurveyImporter;
import edu.upc.prop.domain.classes.util.ConsoleIO;

import java.nio.file.Path;
import java.util.List;

public class ExportarImportarMenu {

    private final ConsoleIO io;
    private final CtrlDominio ctrlDominio;
    private final ConsoleIO.Modo modo;

    public ExportarImportarMenu(ConsoleIO io, CtrlDominio ctrlDominio, ConsoleIO.Modo modo) {
        this.io = io;
        this.ctrlDominio = ctrlDominio;
        this.modo = modo;
    }

    public void ejecutar() {
        CsvSurveyImporter imp = new CsvSurveyImporter();
        CsvSurveyExporter exp = new CsvSurveyExporter();

        while (true) {
            if(modo == ConsoleIO.Modo.MANUAL) {
                System.out.println("\nImportar / Exportar");
                System.out.println("1) Importar encuesta (preguntas y/o respuestas) CSV");
                System.out.println("2) Exportar encuesta (preguntas y respuestas) CSV");
                System.out.println("0) Volver");
            }
            String opcion = io.prompt("Opcion");
            try {
                switch (opcion) {
                    case "1" -> importarEncuesta(imp);
                    case "2" -> exportarEncuesta(exp);
                    case "0" -> {
                        return;
                    }
                    default -> System.out.println("Opcion invalida");
                }
            }
            catch (Exception e) {
                System.out.println("Error en importar/exportar: " + e.getMessage());
            }
        }
    }

    private void importarEncuesta(CsvSurveyImporter imp) throws Exception {
        String ruta = io.prompt("Ruta CSV a importar:");
        if (ruta.isBlank()) {
            System.out.println("Ruta vacia");
            return;
        }
        Path p = Path.of(ruta);
        String id = io.prompt("Id de encuesta para guardar:");
        if (id.isBlank()) {
            System.out.println("Id de encuesta vacio");
            return;
        }

        CsvSurveyImporter.ImportResult res = imp.importSurvey(p, id);

        ctrlDominio.guardar(res.cuestionario);

        ctrlDominio.eliminarTodas(id);
        for (var r : res.respuestas) {
            ctrlDominio.agregar(id, r);
        }

        System.out.println("Importada encuesta " + id + " con " + res.cuestionario.getPreguntas().size() + " preguntas y " + res.respuestas.size() + " respuestas");
    }

    private void exportarEncuesta(CsvSurveyExporter exp) throws Exception {
        Cuestionario en = FuncionesEncuesta.seleccionarEncuesta(io, ctrlDominio);
        if (en == null) return;
        String id = en.getId();

        String ruta = io.prompt("Ruta CSV de salida");
        if (ruta.isBlank()) {
            System.out.println("Ruta vacia, no se exporta nada");
            return;
        }
        Path out = Path.of(ruta);
        List<Respuesta> listaRespuestas = ctrlDominio.listarRespuestas(id);
        exp.exportSurvey(out, en, listaRespuestas); //Exportar

        // Usar println para asegurar salto de línea y flushing en consola
        System.out.println("Exportada encuesta " + id + " con " + listaRespuestas.size() + " respuestas a " + out);
    }
}
package edu.upc.prop.drivers;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.util.ConsoleIO;

import java.util.Collection;

import edu.upc.prop.domain.controllers.CtrlDominio;

public class FuncionesEncuesta {

    //Muestra encuestas disponibles y devuelve false si no hay ninguna
    public static boolean mostrarEncuestasDisponibles(CtrlDominio ctrlDominio, ConsoleIO io) {
        Collection<Cuestionario> en = ctrlDominio.listar();
        if (en.isEmpty()) {
            System.out.println("No hay encuestas");
            return false;
        }

        System.out.println("Encuestas disponibles:");
        for (Cuestionario c : en) { //Se itera sobre la collection de encuestas
            int numResp = ctrlDominio.getSize(c.getId());
            System.out.println(" - " + c.getId() + " (preguntas=" + c.getPreguntas().size() + ", respuestas=" + numResp + ")");
        }
        return true;
    }

    //Se selecciona una encuesta por id, devolviendo null si no existe o no hay encuestas
    public static Cuestionario seleccionarEncuesta(ConsoleIO io, CtrlDominio ctrlDominio) {
        if (!mostrarEncuestasDisponibles(ctrlDominio, io)) return null; //No hay encuestas

        String id = io.prompt("Id de la encuesta");
        Cuestionario en = ctrlDominio.obtener(id);
        if (en == null) {
            if (io.getModo() == ConsoleIO.Modo.MANUAL) System.out.println("No existe encuesta con id '" + id);
            return null;
        }
        return en;
    }
}
package edu.upc.prop.persistence.classes;

import edu.upc.prop.domain.classes.model.Respuesta;
import java.io.*;
import java.util.*;

public class ResponseRepository {
    private final Map<String, List<Respuesta>> porEncuesta = new HashMap<>();

    private List<Respuesta> bucket(String encuestaId) {
        return porEncuesta.computeIfAbsent(encuestaId, k -> new ArrayList<>());
    }

    public void add(String encuestaId, Respuesta r) {
        bucket(encuestaId).add(r);
    }

    public void clear(String encuestaId) {
        porEncuesta.remove(encuestaId);
    }

    public int size(String encuestaId) {
        return porEncuesta.getOrDefault(encuestaId, List.of()).size();
    }

    public List<Respuesta> all(String encuestaId) {
        return Collections.unmodifiableList(porEncuesta.getOrDefault(encuestaId, List.of()));
    }

    public boolean removeById(String encuestaId, String participanteId) {
        List<Respuesta> l = porEncuesta.get(encuestaId);
        if (l == null) return false;
        return l.removeIf(r -> r.getIdParticipante().equals(participanteId));
    }

    public void removeQuestion(String encuestaId, String preguntaId) {
        List<Respuesta> l = porEncuesta.get(encuestaId);
        if (l == null) return;
        for (Respuesta r : l) {
            r.removePregunta(preguntaId);
        }
    }

    // --- Persistencia (Binario) ---

    @SuppressWarnings("unchecked")
    public void cargarDeDisco(String ruta) {
        File f = new File(ruta);
        if (!f.exists()) return;

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f))) {
            Map<String, List<Respuesta>> datos = (Map<String, List<Respuesta>>) ois.readObject();
            porEncuesta.clear();
            porEncuesta.putAll(datos);
        } catch (Exception e) {
            System.err.println("Error cargando respuestas: " + e.getMessage());
        }
    }

    public void guardarEnDisco(String ruta) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(ruta))) {
            oos.writeObject(porEncuesta);
        } catch (Exception e) {
            System.err.println("Error guardando respuestas: " + e.getMessage());
        }
    }
}package edu.upc.prop.persistence.classes;

import edu.upc.prop.domain.classes.model.Cuestionario;
import java.io.*;
import java.util.*;

public class SurveyRepository {
    private final Map<String, Cuestionario> encuestas = new LinkedHashMap<>();

    public Collection<Cuestionario> list() {
        return Collections.unmodifiableCollection(encuestas.values());
    }

    public void create(String id) {
        if (id == null || id.isBlank()) throw new IllegalArgumentException("Id vacio");
        if (encuestas.containsKey(id)) throw new IllegalArgumentException("Ya existe ID: " + id);
        encuestas.put(id, new Cuestionario(id));
    }

    public void put(Cuestionario c) {
        if (c == null) throw new IllegalArgumentException("Cuestionario nulo");
        if (c.getId() == null || c.getId().isBlank()) throw new IllegalArgumentException("Sin ID");
        encuestas.put(c.getId(), c);
    }

    public boolean delete(String id) {
        if (id == null) return false;
        return encuestas.remove(id) != null;
    }

    public boolean exists(String id) {
        return id != null && encuestas.containsKey(id);
    }

    public Cuestionario get(String id) {
        if (id == null) return null;
        return encuestas.get(id);
    }

    @SuppressWarnings("unchecked")
    public void cargarDeDisco(String ruta) {
        File f = new File(ruta);
        if (!f.exists()) return;

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f))) {
            Map<String, Cuestionario> datos = (Map<String, Cuestionario>) ois.readObject();
            encuestas.clear();
            encuestas.putAll(datos);
        } catch (Exception e) {
            System.err.println("Error cargando encuestas: " + e.getMessage());
        }
    }

    public void guardarEnDisco(String ruta) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(ruta))) {
            oos.writeObject(encuestas);
        } catch (Exception e) {
            System.err.println("Error guardando encuestas: " + e.getMessage());
        }
    }
}package edu.upc.prop.persistence.classes;

import edu.upc.prop.domain.classes.model.Usuario;
import java.io.*; // <--- Necesario para leer/escribir archivos
import java.util.HashMap;
import java.util.Map;

public class UserRepository {
    // Mapa en memoria: Email ---> Usuario
    private Map<String, Usuario> usuarios = new HashMap<>();

    // Nombre del archivo donde se guardarán los datos (se crea en la carpeta data del proyecto)
    private final String RUTA_CSV = "data/usuarios.csv";

    public void guardarUsuario(Usuario u) {
        if (u == null) {
            throw new IllegalArgumentException("El usuario no puede ser nulo.");
        }
        if (usuarios.containsKey(u.getEmail())) {
            throw new IllegalArgumentException("Ya existe un usuario con el email: " + u.getEmail());
        }
        usuarios.put(u.getEmail(), u);
    }

    public Usuario getUsuario(String email) {
        return usuarios.get(email);
    }

    public boolean existeUsuario(String email) {
        return usuarios.containsKey(email);
    }

    public Map<String, Usuario> getTodos() {
        return usuarios;
    }

    // Leer del archivo al iniciar la app
    public void cargarDeDisco() {
        File f = new File(RUTA_CSV);
        if (!f.exists()) return; // Si es la primera vez y no hay archivo, no hacemos nada

        try (BufferedReader br = new BufferedReader(new FileReader(f))) {
            String linea;
            while ((linea = br.readLine()) != null) {
                // El formato esperado es: email,pass,nombre,apellido,nacimiento
                String[] partes = linea.split(",");
                if (partes.length == 5) {
                    Usuario u = new Usuario(partes[0], partes[1], partes[2], partes[3], partes[4]);
                    usuarios.put(u.getEmail(), u);
                }
            }
            System.out.println("-> Usuarios cargados desde disco: " + usuarios.size());
        } catch (IOException e) {
            System.err.println("Error leyendo usuarios: " + e.getMessage());
        }
    }

    // Guardar al archivo al cerrar la app
    public void guardarEnDisco() {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(RUTA_CSV))) {
            for (Usuario u : usuarios.values()) {
                // Escribimos una línea por usuario separada por comas
                String linea = String.join(",",
                        u.getEmail(), u.getPassword(), u.getNombre(), u.getApellido(), u.getFechaNacimiento());
                bw.write(linea);
                bw.newLine();
            }
            System.out.println("-> Usuarios guardados en " + RUTA_CSV);
        } catch (IOException e) {
            System.err.println("Error guardando usuarios: " + e.getMessage());
        }
    }
}package edu.upc.prop.persistence.controllers;

import edu.upc.prop.persistence.classes.SurveyRepository;
import edu.upc.prop.persistence.classes.ResponseRepository;
import edu.upc.prop.persistence.classes.UserRepository;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.Usuario;

import java.util.Collection;
import java.util.List;
import java.io.File; // <--- Importante para manejar directorios

// Gestiona los repositorios y la carga/guardado de datos
public class CtrlPersistencia {

    private final SurveyRepository surveyRepository;
    private final ResponseRepository responseRepository;
    private final UserRepository userRepository;

    // Archivos de persistencia
    private final String FILE_ENCUESTAS = "data/datos_encuestas.bin";
    private final String FILE_RESPUESTAS = "data/datos_respuestas.bin";

    public CtrlPersistencia() {
        this.surveyRepository = new SurveyRepository();
        this.responseRepository = new ResponseRepository();
        this.userRepository = new UserRepository();

        cargarDatos();
    }

    private void cargarDatos() {
        // Carga inicial al arrancar
        //System.out.println("--- Iniciando Carga de Datos ---"); lo quito xq aparece al inicio del output de los juegos de prueba y no tiene por que aparecer
        userRepository.cargarDeDisco();
        surveyRepository.cargarDeDisco(FILE_ENCUESTAS);
        responseRepository.cargarDeDisco(FILE_RESPUESTAS);
        //System.out.println("--------------------------------");
    }

    public void guardarDatos() {
        System.out.println("--- Guardando Datos ---");

        // Aseguramos que la carpeta exista antes de escribir
        asegurarCarpetaData();

        // Guardamos
        userRepository.guardarEnDisco();
        surveyRepository.guardarEnDisco(FILE_ENCUESTAS);
        responseRepository.guardarEnDisco(FILE_RESPUESTAS);
        System.out.println("-----------------------");
    }

    //Por si se borra la carpeta data
    private void asegurarCarpetaData() {
        File directorio = new File("data");
        if (!directorio.exists()) {
            boolean creado = directorio.mkdirs();
            if (creado) {
                System.out.println(">> Carpeta 'data' creada automáticamente.");
            }
        }
    }

    // Delegación Encuestas
    public Collection<Cuestionario> Elist() { return surveyRepository.list(); }
    public void Ecreate(String id) { surveyRepository.create(id); }
    public void Eput(Cuestionario c) { surveyRepository.put(c); }
    public boolean Edelete(String id) { return surveyRepository.delete(id); }
    public boolean Eexists(String id) { return surveyRepository.exists(id); }
    public Cuestionario Eget(String id) { return surveyRepository.get(id); }

    // Delegación Respuestas
    public void Radd(String encuestaId, Respuesta r) { responseRepository.add(encuestaId, r); }
    public void Rclear(String encuestaId) { responseRepository.clear(encuestaId); }
    public int Rsize(String encuestaId) { return responseRepository.size(encuestaId); }
    public List<Respuesta> Rall(String encuestaId) { return responseRepository.all(encuestaId); }
    public boolean RremoveById(String eId, String pId) { return responseRepository.removeById(eId, pId); }
    public void RremoveQuestion(String eId, String qId) { responseRepository.removeQuestion(eId, qId); }

    // Delegación Usuarios
    public void Usave(Usuario u) { userRepository.guardarUsuario(u); }
    public Usuario Uget(String email) { return userRepository.getUsuario(email); }
    public boolean Uexists(String email) { return userRepository.existeUsuario(email); }
}package edu.upc.prop;

import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;
import edu.upc.prop.presentation.controllers.CtrlPresentacion;

public class App {
    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                // 1. Inicialización de la Capa de Persistencia
                // (Al crearse, ahora cargará automáticamente los datos si existen)
                CtrlPersistencia ctrlPersistencia = new CtrlPersistencia();

                // 2. Inicialización de la Capa de Dominio
                CtrlDominio ctrlDominio = new CtrlDominio(ctrlPersistencia);

                // 3. Inicialización de la Capa de Presentación
                CtrlPresentacion ctrlPresentacion = new CtrlPresentacion(ctrlDominio);

                // GUARDADO AUTOMÁTICO AL CERRAR
                // Este bloque se ejecuta siempre que cierras la ventana o paras el programa.
                Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                    System.out.println("\n>> Cerrando aplicación... Guardando datos...");
                    ctrlPersistencia.guardarDatos();
                }));

                // 4. Inicio de la Aplicación
                ctrlPresentacion.inicializarPresentacion();
            }
        });
    }
}package edu.upc.prop.domain.classes.util;

import java.util.Scanner;

public class ConsoleIO {

    public enum Modo { MANUAL, AUTOMATICO }

    private final Scanner sc = new Scanner(System.in);
    private Modo modo = Modo.AUTOMATICO;

    public void setModo(Modo modo) {
        this.modo = modo;
    }

    public Modo getModo() {
        return modo;
    }

    public String prompt(String label){
        if (modo == Modo.MANUAL) {
            System.out.print(label + ": ");
        }
        if (!sc.hasNextLine()) {
            System.out.println("\nNo hay entrada interactiva.");
            System.exit(0);
        }
        return sc.nextLine().trim();
    }

    public String promptDefault(String label, String defaultVal){
        if (modo == Modo.MANUAL) {
            System.out.print(label + " [" + defaultVal + "]: ");
        }
        if (!sc.hasNextLine()) {
            System.out.println("\nNo hay entrada interactiva.");
            System.exit(0);
        }
        String s = sc.nextLine();
        return s.isBlank() ? defaultVal : s.trim();
    }

    public int promptInt(String label){
        while (true){
            try { return Integer.parseInt(prompt(label)); }
            catch (NumberFormatException e){
                if (modo == Modo.MANUAL) System.out.println("Introduce un entero válido.");
            }
        }
    }
}
package edu.upc.prop.domain.classes.distance;

import edu.upc.prop.domain.classes.vector.Vectorizer;

public class GowerDistance implements Distance {
    @Override
    // Submetodo para calcular la distancia entre dos valores numéricos normalizados
    public double calcularDistanciaNumerica(double valA, double valB) {
        return Math.abs(valA - valB);
    }

    @Override
    public double dist(Vectorizer.Point a, Vectorizer.Point b) {
        double[] x = a.values(), y = b.values();
        boolean[] mx = a.missing(), my = b.missing();
        double sum=0; int cnt=0;
        for (int i=0;i<x.length;i++){
            if (mx[i] || my[i]) continue;
            sum += calcularDistanciaNumerica(x[i], y[i]); // valores normalizados [0,1]
            cnt++;
        }
        if (cnt==0) return 1.0;
        return sum / cnt;
    }
}
package edu.upc.prop.domain.classes.distance;

import edu.upc.prop.domain.classes.vector.Vectorizer;

public interface Distance {
    double calcularDistanciaNumerica(double a, double b);
    double dist(Vectorizer.Point a, Vectorizer.Point b);
}
package edu.upc.prop.domain.classes.impexp;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.distance.GowerDistance;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.model.ValorRespuesta;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public class CsvClusterExporter {

    /**
     Exporta el resultado de clustering.

     Formato:
     # algorithm=...
     # SSE=...
     # Silhouette=...
     # time_ms=...
     # representatives:
     # cluster 0 -> centro_0 (nearest=resp_3, dist=0.123456)
     # cluster 1 -> resp_5 (medoid)
     P1,P2,P3,...,clusterId
     v1,v2,"a|b|c",...,0
     ...
     */
    public void exportClusterResult(Path path,
                                    ClusterResult result,
                                    Double sse,
                                    Double silhouette,
                                    Long elapsedMillis,
                                    Cuestionario cuestionario,
                                    List<Respuesta> respuestas) throws IOException {

        Map<String, Respuesta> respById = new HashMap<>();
        for (Respuesta r : respuestas) {
            respById.put(r.getIdParticipante(), r);
        }

        List<Pregunta> preguntas = cuestionario.getPreguntas();

        // Preparamos los puntos vectorizados para poder medir distancias
        List<Vectorizer.Point> puntos = new ArrayList<>();
        Map<String, Vectorizer.Point> puntoPorId = new HashMap<>();
        if (!respuestas.isEmpty()) {
            Vectorizer v = new Vectorizer();
            v.fit(cuestionario, respuestas);
            puntos = v.transformAll(respuestas, cuestionario);
            for (Vectorizer.Point p : puntos) {
                puntoPorId.put(p.id(), p);
            }
        }
        GowerDistance dist = new GowerDistance();

        try (BufferedWriter bw = Files.newBufferedWriter(path)) {

            // Metadatos
            bw.write("# algorithm=" + result.algorithm());
            bw.newLine();
            if (sse != null && !Double.isNaN(sse)) {
                bw.write(String.format(Locale.US, "# SSE=%.6f", sse));
                bw.newLine();
            }
            if (silhouette != null && !Double.isNaN(silhouette)) {
                bw.write(String.format(Locale.US, "# Silhouette=%.6f", silhouette));
                bw.newLine();
            }
            if (elapsedMillis != null && elapsedMillis >= 0) {
                bw.write("# time_ms=" + elapsedMillis);
                bw.newLine();
            }

            // Información de representantes
            bw.write("# representatives:");
            bw.newLine();

            // Agrupar puntos por cluster para buscar el más cercano al centroide
            Map<Integer, List<Vectorizer.Point>> puntosPorCluster = new HashMap<>();
            for (Map.Entry<String,Integer> e : result.assignments().entrySet()) {
                String pid = e.getKey();
                Integer cid = e.getValue();
                Vectorizer.Point p = puntoPorId.get(pid);
                if (p == null) continue;
                puntosPorCluster.computeIfAbsent(cid, k -> new ArrayList<>()).add(p);
            }

            for (int cid = 0; cid < result.representatives().size(); cid++) {
                Vectorizer.Point rep = result.representatives().get(cid);

                // Caso K-Means / K-Means++: centroide sintético
                if (rep.id().startsWith("centro_")) {
                    List<Vectorizer.Point> miembros = puntosPorCluster.getOrDefault(cid, List.of());
                    String nearestId = "(ninguno)";
                    double best = Double.POSITIVE_INFINITY;

                    for (Vectorizer.Point p : miembros) {
                        double d = dist.dist(p, rep);
                        if (d < best) {
                            best = d;
                            nearestId = p.id();
                        }
                    }

                    if (Double.isInfinite(best)) best = 0.0; // por si el cluster está vacío

                    bw.write(String.format(Locale.US,
                            "# cluster %d -> %s (nearest=%s, dist=%.6f)",
                            cid, rep.id(), nearestId, best));
                    bw.newLine();
                }
                // Caso K-Medoids: el representante ya es un dato real
                else {
                    bw.write("# cluster " + cid + " -> " + rep.id() + " (medoid)");
                    bw.newLine();
                }
            }

            // Cabecera de datos: una columna por pregunta + clusterId
            for (int i = 0; i < preguntas.size(); i++) {
                bw.write(preguntas.get(i).getId());
                if (i + 1 < preguntas.size()) bw.write(",");
            }
            bw.write(",clusterId");
            bw.newLine();

            // Filas de datos
            for (Map.Entry<String, Integer> e : result.assignments().entrySet()) {
                String pid = e.getKey();
                Integer cid = e.getValue();

                Respuesta r = respById.get(pid);

                StringBuilder row = new StringBuilder();
                if (r != null) {
                    for (int i = 0; i < preguntas.size(); i++) {
                        Pregunta p = preguntas.get(i);
                        ValorRespuesta valWrapper = r.getValores().get(p.getId());
                        String out = "";

                        if (valWrapper != null) {
                            out = valWrapper.getValorNormalizado();

                            if (p.getTipo() == TipoPregunta.OPCION_MULTIPLE) {
                                out = out.replace(",", "|");
                            }
                        }

                        row.append(out);
                        if (i + 1 < preguntas.size()) row.append(",");
                    }
                } else {
                    // Si no encontramos la respuesta, dejamos columnas vacías
                    for (int i = 0; i < preguntas.size(); i++) {
                        if (i > 0) row.append(",");
                    }
                }

                // Añadir el clusterId al final
                row.append(",");
                row.append(cid);

                bw.write(row.toString());
                bw.newLine();
            }
        }
    }
}
package edu.upc.prop.domain.classes.impexp;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.model.ValorRespuesta;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

public class CsvSurveyExporter {

    private String tipoToString(TipoPregunta tp) {
        return switch (tp) {
            case TEXTO -> "TEXTUAL";
            case NUMERICA -> "NUMERICA";
            case OPCION_UNICA -> "OPCION_UNICA";
            case OPCION_MULTIPLE -> "OPCION_MULTIPLE";
        };
    }

    public void exportSurvey(Path path, Cuestionario c, List<Respuesta> respuestas) throws IOException {
        try (BufferedWriter bw = Files.newBufferedWriter(path)) {
            List<Pregunta> preguntas = c.getPreguntas();

            // Fila 0: IDs
            for (int j = 0; j < preguntas.size(); j++) {
                bw.write(preguntas.get(j).getId());
                if (j + 1 < preguntas.size()) bw.write(",");
            }
            bw.newLine();

            // Fila 1: Tipos
            for (int j = 0; j < preguntas.size(); j++) {
                bw.write(tipoToString(preguntas.get(j).getTipo()));
                if (j + 1 < preguntas.size()) bw.write(",");
            }
            bw.newLine();

            // Fila 2: OPCIONES + MAX SELECCION
            for (int j = 0; j < preguntas.size(); j++) {
                Pregunta p = preguntas.get(j);
                List<String> opts = p.getOpciones();
                if (opts != null && !opts.isEmpty()) {
                    String joined = String.join("|", opts);

                    // --- NUEVO: Si tiene límite de selección, lo pegamos al final ---
                    if (p.getTipo() == TipoPregunta.OPCION_MULTIPLE && p.getMaxSeleccion() > 0) {
                        joined += "<<MAX:" + p.getMaxSeleccion() + ">>";
                    }
                    // ----------------------------------------------------------------

                    bw.write(joined);
                } else {
                    bw.write("");
                }
                if (j + 1 < preguntas.size()) bw.write(",");
            }
            bw.newLine();

            // Resto: Respuestas
            for (Respuesta r : respuestas) {
                for (int j = 0; j < preguntas.size(); j++) {
                    Pregunta p = preguntas.get(j);
                    ValorRespuesta valWrapper = r.getValores().get(p.getId());
                    String out = "";
                    if (valWrapper != null) {
                        out = valWrapper.getValorNormalizado();
                    }
                    bw.write(out);
                    if (j + 1 < preguntas.size()) bw.write(",");
                }
                bw.newLine();
            }
        }
    }
}package edu.upc.prop.domain.classes.impexp;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.model.ValorRespuestaNumerica;
import edu.upc.prop.domain.classes.model.ValorRespuestaTextual;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionUnica;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionMultiple;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CsvSurveyImporter {

    public static class ImportResult {
        public final Cuestionario cuestionario;
        public final List<Respuesta> respuestas;
        public ImportResult(Cuestionario c, List<Respuesta> r){
            this.cuestionario = c;
            this.respuestas = r;
        }
    }

    private static TipoPregunta parseTipo(String raw) {
        if (raw == null) return TipoPregunta.TEXTO;
        String t = raw.trim().toUpperCase();
        return switch (t) {
            case "NUMERICA" -> TipoPregunta.NUMERICA;
            case "TEXTO", "TEXTUAL" -> TipoPregunta.TEXTO;
            case "OPCION_UNICA", "OPCIÓN_UNICA" -> TipoPregunta.OPCION_UNICA;
            case "OPCION_MULTIPLE", "OPCIÓN_MULTIPLE" -> TipoPregunta.OPCION_MULTIPLE;
            default -> TipoPregunta.TEXTO;
        };
    }

    public ImportResult importSurvey(Path path, String surveyId) throws IOException {
        List<Respuesta> respuestas = new ArrayList<>();
        Cuestionario cuestionario = new Cuestionario(surveyId);

        try (BufferedReader br = Files.newBufferedReader(path)) {
            // 1. Header
            String header = br.readLine();
            if (header == null) throw new IOException("CSV vacío: " + path);
            String[] cols = header.split(",", -1);

            // 2. Tipos
            String typeLine = br.readLine();
            if (typeLine == null) throw new IOException("CSV sin fila de tipos: " + path);
            String[] types = typeLine.split(",", -1);

            // 3. Opciones + Max Seleccion
            String optionsLine = br.readLine();
            String[] optionsRaw = (optionsLine != null) ? optionsLine.split(",", -1) : null;

            int numCols = cols.length;
            String[] preguntaIds = new String[numCols];
            TipoPregunta[] tipos = new TipoPregunta[numCols];

            for (int j = 0; j < numCols; j++) {
                String enunciado = cols[j].trim();
                if (enunciado.isEmpty()) enunciado = "Pregunta_" + (j + 1);
                preguntaIds[j] = enunciado;

                tipos[j] = parseTipo(types[j]);
                TipoPregunta tipo = tipos[j];

                List<String> opciones = new ArrayList<>();
                int maxSel = 0; // Por defecto 0 (sin límite)

                if (optionsRaw != null && j < optionsRaw.length) {
                    String rawOps = optionsRaw[j].trim();

                    // --- NUEVO: DETECTAR MAX SELECCION ---
                    // Buscamos si el string termina con <<MAX:n>>
                    if (rawOps.contains("<<MAX:")) {
                        try {
                            int start = rawOps.indexOf("<<MAX:");
                            int end = rawOps.indexOf(">>", start);
                            if (end > start) {
                                String numStr = rawOps.substring(start + 6, end);
                                maxSel = Integer.parseInt(numStr);
                                // Quitamos la etiqueta para dejar solo las opciones
                                rawOps = rawOps.substring(0, start);
                            }
                        } catch (Exception e) {
                            // Si falla el parseo, ignoramos el max
                        }
                    }
                    // -------------------------------------

                    if (!rawOps.isEmpty()) {
                        String[] parts = rawOps.split("\\|");
                        opciones = new ArrayList<>(Arrays.asList(parts));
                    }
                }

                cuestionario.addPregunta(new Pregunta(
                        preguntaIds[j], preguntaIds[j], tipo, opciones, maxSel
                ));
            }

            // 4. Datos (Respuestas)
            String line;
            int respIndex = 1;
            while ((line = br.readLine()) != null) {
                if (line.isBlank()) continue;
                String[] row = line.split(",", -1);

                String participanteId = "imp_" + respIndex++;
                Respuesta r = new Respuesta(participanteId);

                for (int j = 0; j < numCols; j++) {
                    if (j >= row.length) continue;
                    String raw = row[j].trim();
                    if (raw.isEmpty()) continue;

                    String pid = preguntaIds[j];
                    Pregunta p = cuestionario.getPregunta(pid);
                    List<String> opciones = p.getOpciones();

                    switch (tipos[j]) {
                        case NUMERICA -> {
                            try {
                                r.put(pid, new ValorRespuestaNumerica(Double.parseDouble(raw)));
                            } catch (NumberFormatException ignored) { }
                        }
                        case TEXTO -> r.put(pid, new ValorRespuestaTextual(raw));
                        case OPCION_UNICA -> {
                            int idx = opciones.indexOf(raw);
                            if (idx != -1) r.put(pid, new ValorRespuestaOpcionUnica(idx));
                        }
                        case OPCION_MULTIPLE -> {
                            String[] parts = raw.split("\\|");
                            List<Integer> indicesSel = new ArrayList<>();
                            for (String part : parts) {
                                int idx = opciones.indexOf(part.trim());
                                if (idx != -1) indicesSel.add(idx);
                            }
                            if (!indicesSel.isEmpty()) {
                                r.put(pid, new ValorRespuestaOpcionMultiple(indicesSel));
                            }
                        }
                    }
                }
                respuestas.add(r);
            }
        }
        return new ImportResult(cuestionario, respuestas);
    }
}package edu.upc.prop.domain.classes.clustering;

import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class KMeans extends ClusteringAlgorithm{
    public KMeans() {
        super(13);
    }

    public ClusterResult run(List<Vectorizer.Point> data, int k, Distance dist, boolean useKPP, int maxIter){
        List<Vectorizer.Point> centers;
        if (useKPP) centers = new KMeansPlusPlus().init(data, k, dist);
        else centers = sample(data, k);

        Map<String,Integer> assign = new LinkedHashMap<>();

        for (int it=0; it<maxIter; it++){
            boolean changed = assignToCenters(data, centers, dist, assign);
            List<Vectorizer.Point> newCenters = recomputeCenters(data, assign, k);
            if (!changed || same(centers, newCenters)) { centers = newCenters; break; }
            centers = newCenters;
        }
        return new ClusterResult("k-means" + (useKPP?"++":""), assign, centers);
    }

    @Override
    public ClusterResult run(List<Vectorizer.Point> data, int k, Distance dist, int maxIter) {
        return run(data, k, dist, false, maxIter);
    }

    private List<Vectorizer.Point> recomputeCenters(List<Vectorizer.Point> data, Map<String,Integer> assign, int k){
        int dim = data.get(0).values().length;
        double[][] sum = new double[k][dim];
        boolean[][] miss = new boolean[k][dim];
        int[] cnt = new int[k];

        Map<String, Vectorizer.Point> byId = new HashMap<>();
        for (var p : data) byId.put(p.id(), p);

        for (int c=0;c<k;c++) Arrays.fill(miss[c], true);

        for (var e: assign.entrySet()){
            int c = e.getValue();
            var p = byId.get(e.getKey());
            double[] v = p.values();
            boolean[] m = p.missing();
            for (int i=0;i<dim;i++){
                if (!m[i]) { sum[c][i] += v[i]; miss[c][i] = false; }
            }
            cnt[c]++;
        }

        List<Vectorizer.Point> out = new ArrayList<>();
        for (int c=0;c<k;c++){
            double[] v = new double[dim];
            boolean[] m = new boolean[dim];
            for (int i=0;i<dim;i++){
                if (miss[c][i] || cnt[c]==0) { v[i]=0; m[i]=true; }
                else { v[i] = sum[c][i] / cnt[c]; m[i]=false; }
            }
            out.add(new Vectorizer.Point("centro_"+c, v, m));
        }
        return out;
    }


    private boolean same(List<Vectorizer.Point> a, List<Vectorizer.Point> b){
        if (a.size()!=b.size()) return false;
        for (int i=0;i<a.size();i++){
            double[] va = a.get(i).values(), vb = b.get(i).values();
            if (va.length!=vb.length) return false;
            for (int j=0;j<va.length;j++) if (Math.abs(va[j]-vb[j])>1e-9) return false;
        }
        return true;
    }
}
package edu.upc.prop.domain.classes.clustering;

import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class KMedoids extends ClusteringAlgorithm{
    public KMedoids() {
        super(23);
    }

    @Override
    public ClusterResult run(List<Vectorizer.Point> data, int k, Distance dist, int maxIter){
        List<Vectorizer.Point> medoids = sample(data, k);
        Map<String,Integer> assign = new LinkedHashMap<>();
        assignToCenters(data, medoids, dist, assign);

        for (int it=0; it<maxIter; it++){
            boolean improved = false;
            for (int i=0;i<k;i++){
                Vectorizer.Point mi = medoids.get(i);
                for (var cand : data){
                    if (medoids.contains(cand)) continue;
                    List<Vectorizer.Point> newMed = new ArrayList<>(medoids);
                    newMed.set(i, cand);

                    double oldCost = cost(data, medoids, dist);
                    double newCost = cost(data, newMed, dist);

                    if (newCost + 1e-9 < oldCost){
                        medoids = newMed;
                        assignToCenters(data, medoids, dist, assign);
                        improved = true;
                    }
                }
            }
            if (!improved) break;
        }
        return new ClusterResult("k-medoids", assign, medoids);
    }

    private double cost(List<Vectorizer.Point> data, List<Vectorizer.Point> medoids, Distance dist){
        double s=0;
        for (var p: data){
            double bd = Double.POSITIVE_INFINITY;
            for (var m: medoids) bd = Math.min(bd, dist.dist(p, m));
            s += bd;
        }
        return s;
    }
}
package edu.upc.prop.domain.classes.clustering;

import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public abstract class ClusteringAlgorithm {
    protected final Random rnd;

    public ClusteringAlgorithm(long seed) {
        this.rnd = new Random(seed);
    }

    public abstract ClusterResult run(List<Vectorizer.Point> data, int k, Distance dist, int maxIter);

    protected boolean assignToCenters(List<Vectorizer.Point> data, List<Vectorizer.Point> centers, Distance dist,
                                      Map<String,Integer> assign){
        boolean changed = false;
        for (var p: data){
            int best = -1; double bd = Double.POSITIVE_INFINITY;
            for (int c=0; c<centers.size(); c++){
                double d = dist.dist(p, centers.get(c));
                if (d < bd){ bd = d; best = c; }
            }
            Integer prev = assign.put(p.id(), best);
            // La condición de cambio es importante para el bucle de K-Means.
            if (prev == null || prev != best) changed = true;
        }
        return changed; // Retorna si hubo cambios, útil para K-Means
    }

    protected List<Vectorizer.Point> sample(List<Vectorizer.Point> data, int k){
        List<Vectorizer.Point> copy = new ArrayList<>(data);
        Collections.shuffle(copy, rnd);
        return new ArrayList<>(copy.subList(0, k));
    }
}package edu.upc.prop.domain.classes.clustering;

import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class ClusterResult {
    private final String algorithm;
    private final Map<String,Integer> assignment = new LinkedHashMap<>();
    private final List<Vectorizer.Point> representatives;

    public ClusterResult(String algorithm, Map<String,Integer> assignment, List<Vectorizer.Point> representatives) {
        this.algorithm = algorithm;
        this.assignment.putAll(assignment);
        this.representatives = representatives;
    }

    public String algorithm(){ return algorithm; }
    public Map<String,Integer> assignments(){ return Collections.unmodifiableMap(assignment); }
    public List<Vectorizer.Point> representatives(){ return representatives; }
}
package edu.upc.prop.domain.classes.clustering;

import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class KMeansPlusPlus {
    private final Random rnd = new Random(7);

    public List<Vectorizer.Point> init(List<Vectorizer.Point> data, int k, Distance dist){
        if (k<=0 || k>data.size()) throw new IllegalArgumentException("k inválido");
        List<Vectorizer.Point> centers = new ArrayList<>();
        centers.add(data.get(rnd.nextInt(data.size())));

        double[] minD2 = new double[data.size()];
        Arrays.fill(minD2, Double.POSITIVE_INFINITY);

        while (centers.size() < k){
            var last = centers.get(centers.size()-1);
            for (int i=0;i<data.size();i++){
                double d = dist.dist(data.get(i), last);
                double d2 = d*d;
                if (d2 < minD2[i]) minD2[i] = d2;
            }
            double sum = 0; for (double v: minD2) sum += v;
            double r = rnd.nextDouble() * sum;
            double acc = 0;
            for (int i=0;i<data.size();i++){
                acc += minD2[i];
                if (acc >= r) { centers.add(data.get(i)); break; }
            }
        }
        return centers;
    }
}
package edu.upc.prop.domain.classes.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.Serializable;

public class Cuestionario implements Serializable {
    private final String id;
    private String ownerId;
    private final List<Pregunta> preguntas = new ArrayList<>();
    private final Map<String, Pregunta> idx = new HashMap<>();

    public Cuestionario(String id) {
        this.id = id;
    }

    public void setOwner(String ownerId) {
        this.ownerId = ownerId;
    }

    public String getOwner() {
        return this.ownerId;
    }

    public String getId() {
        return this.id;
    }

    public List<Pregunta> getPreguntas() {
        return Collections.unmodifiableList(this.preguntas);
    }

    public boolean existsPregunta(String idPregunta) {
        return this.idx.containsKey(idPregunta);
    }

    public void addPregunta(Pregunta p) {
        if (this.idx.containsKey(p.getId())) {
            throw new IllegalArgumentException("Ya existe una pregunta con id: " + p.getId());
        } else {
            this.preguntas.add(p);
            this.idx.put(p.getId(), p);
        }
    }

    public Pregunta getPregunta(String idPregunta) {
        return this.idx.get(idPregunta);
    }

    public boolean eliminarPregunta(String idPregunta) {
        Pregunta p = this.idx.remove(idPregunta);
        if (p == null) {
            return false;
        } else {
            this.preguntas.remove(p);
            return true;
        }
    }

    public boolean reemplazarPregunta(String idPregunta, Pregunta nueva) {
        Pregunta old = this.idx.get(idPregunta);
        if (old == null) {
            return false;
        } else {
            int pos = this.preguntas.indexOf(old);
            this.preguntas.set(pos, nueva);
            this.idx.put(idPregunta, nueva);
            return true;
        }
    }
}package edu.upc.prop.domain.classes.model;

public enum TipoPregunta {
    OPCION_UNICA, OPCION_MULTIPLE, NUMERICA, TEXTO
}package edu.upc.prop.domain.classes.model;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.io.Serializable;

public class Respuesta implements Serializable {

    private final String idParticipante;
    private final Map<String, ValorRespuesta> valores = new LinkedHashMap<>();

    public Respuesta(String idParticipante) {
        this.idParticipante = idParticipante;
    }

    public String getIdParticipante() {
        return this.idParticipante;
    }

    public Map<String, ValorRespuesta> getValores() {
        return Collections.unmodifiableMap(this.valores);
    }

    public void put(String idPregunta, ValorRespuesta valor) {
        this.valores.put(idPregunta, valor);
    }

    public void removePregunta(String idPregunta) {
        this.valores.remove(idPregunta);
    }
}package edu.upc.prop.domain.classes.model;

public class ValorRespuestaOpcionUnica extends ValorRespuesta {
    // Almacena el índice de la opción seleccionada.
    private final int indiceSeleccionado;

    public ValorRespuestaOpcionUnica(int indiceSeleccionado) {
        this.indiceSeleccionado = indiceSeleccionado;
    }

    public int getIndiceSeleccionado() {
        return indiceSeleccionado;
    }

    @Override
    public String getValorNormalizado() {
        // Devuelve el índice como String para normalización
        return String.valueOf(indiceSeleccionado);
    }

    @Override
    public String toString() {
        // Devuelve el índice + 1 para que sea legible (opción 1, opción 2...)
        // O simplemente el índice.
        return String.valueOf(this.indiceSeleccionado);
    }
}package edu.upc.prop.domain.classes.model;

import java.util.List;
import java.io.Serializable;

public class Pregunta implements Serializable {
    private final String id;
    private final String enunciado;
    private final TipoPregunta tipo;
    private final List<String> opciones;
    private final int maxSeleccion;

    public Pregunta(String id, String enunciado, TipoPregunta tipo, List<String> opciones, int maxSeleccion) {
        this.id = id;
        this.enunciado = enunciado;
        this.tipo = tipo;
        this.opciones = opciones;
        this.maxSeleccion = maxSeleccion;
    }

    public String getId() {
        return this.id;
    }
    public String getEnunciado() {
        return this.enunciado;
    }
    public TipoPregunta getTipo() {
        return this.tipo;
    }
    public List<String> getOpciones() {
        return this.opciones;
    }
    public int getMaxSeleccion() {
        return this.maxSeleccion;
    }
}package edu.upc.prop.domain.classes.model;

import java.io.Serializable;

public class Usuario implements Serializable {
    private String email;
    private String password;
    private String nombre;
    private String apellido;
    private String fechaNacimiento;

    public Usuario(String email, String password, String nombre, String apellido, String fechaNacimiento) {
        this.email = email;
        this.password = password;
        this.nombre = nombre;
        this.apellido = apellido;
        this.fechaNacimiento = fechaNacimiento;
    }

    public String getEmail() {
        return email;
    }
    public String getNombre() {
        return nombre;
    }

    public boolean checkPassword(String input) {
        return this.password.equals(input);
    }

    public String getPassword() {
        return password;
    }
    public String getApellido() {
        return apellido;
    }
    public String getFechaNacimiento() {
        return fechaNacimiento;
    }
}package edu.upc.prop.domain.classes.model;

import java.io.Serializable;

public abstract class ValorRespuesta implements Serializable {
    public abstract String getValorNormalizado();
}package edu.upc.prop.domain.classes.model;

public class ValorRespuestaNumerica extends ValorRespuesta {
    private final double valor;

    public ValorRespuestaNumerica(double valor) {
        this.valor = valor;
    }

    public double getValor() {
        return valor;
    }

    @Override
    public String getValorNormalizado() {
        return String.valueOf(valor);
    }

    @Override
    public String toString() {
        // Convierte el double a string.
        return String.valueOf(this.valor);
    }
}package edu.upc.prop.domain.classes.model;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class ValorRespuestaOpcionMultiple extends ValorRespuesta {
    // Almacena una lista de los índices de las opciones seleccionadas.
    private final List<Integer> indicesSeleccionados;

    public ValorRespuestaOpcionMultiple(List<Integer> indicesSeleccionados) {
        this.indicesSeleccionados = Collections.unmodifiableList(indicesSeleccionados);
    }

    public List<Integer> getIndicesSeleccionados() {
        return indicesSeleccionados;
    }

    @Override
    public String getValorNormalizado() {
        return indicesSeleccionados.stream()
                .map(String::valueOf)
                .collect(Collectors.joining(","));
    }

    @Override
    public String toString() {
        return this.indicesSeleccionados.toString();
    }
}package edu.upc.prop.domain.classes.model;

public class ValorRespuestaTextual extends ValorRespuesta {
    private final String valor;

    public ValorRespuestaTextual(String valor) {
        this.valor = valor;
    }

    public String getValor() {
        return valor;
    }

    @Override
    public String getValorNormalizado() {
        return valor;
    }

    @Override
    public String toString() {
        return this.valor;
    }
}package edu.upc.prop.domain.classes.evaluation;

import edu.upc.prop.domain.classes.clustering.ClusterResult;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public class ClusteringAccuracy {

    /**
       Calcula la accuracy comparando:
        - El cluster asignado a cada respuesta y la etiqueta real de la ÚLTIMA columna del CSV.

       El CSV puede ser de dos tipos:
        - Exportado por nuestro programa: fila 0 = cabecera, fila 1 = tipos (NUMERICA, TEXTUAL...),
          filas 2..N = datos.
        - Externo fila 0 = cabecera, filas 1..N = datos.

       Para ello agregaremos un sistema para detectar si la fila 1 es de tipos o de datos.
     */
    public static double accuracyFromCsv(ClusterResult res, Path csvPath) throws IOException {
        // 1) Cargar etiquetas verdaderas en orden
        List<String> trueLabels = loadLabelsInOrder(csvPath);
        if (trueLabels.isEmpty()) {
            throw new IllegalStateException("No se han encontrado etiquetas en el CSV: " + csvPath);
        }

        // 2) entries = (participanteId, clusterId) en el mismo orden de vectorización
        List<Map.Entry<String,Integer>> entries = new ArrayList<>(res.assignments().entrySet());
        if (entries.isEmpty()) {
            throw new IllegalStateException("El resultado de clustering no contiene asignaciones.");
        }

        // 3) Emparejar por orden hasta el mínimo común
        int n = Math.min(entries.size(), trueLabels.size());
        if (n == 0) {
            throw new IllegalStateException(
                    "No hay interseccion entre respuestas vectorizadas y filas de datos del CSV (n=0).");
        }

        // Conjuntos de clusters y clases realmente presentes en esas n filas
        Set<Integer> clusterSet = new LinkedHashSet<>();
        Set<String> labelSet = new LinkedHashSet<>();
        for (int i = 0; i < n; i++) {
            clusterSet.add(entries.get(i).getValue());
            labelSet.add(trueLabels.get(i));
        }

        int numClusters = clusterSet.size();
        int numLabelClasses = labelSet.size();

        if (numClusters != numLabelClasses) {
            throw new IllegalStateException(
                    "Numero de clusters distintos en el resultado (" + numClusters +
                            ") distinto al numero de clases distintas en la ultima columna del CSV (" +
                            numLabelClasses + "). " +
                            "Elige k igual al numero de clases o revisa el CSV."
            );
        }
        int K = numClusters;

        // clusterId -> índice 0..K-1
        Integer[] clusterIds = clusterSet.toArray(new Integer[0]);
        Map<Integer,Integer> clusterIdToIdx = new HashMap<>();
        for (int i = 0; i < K; i++) clusterIdToIdx.put(clusterIds[i], i);

        // labelName -> índice 0..K-1
        String[] labelNames = labelSet.toArray(new String[0]);
        Map<String,Integer> labelToIdx = new HashMap<>();
        for (int i = 0; i < K; i++) labelToIdx.put(labelNames[i], i);

        // Permutaciones de 0..K-1
        int[] perm = new int[K];
        for (int i = 0; i < K; i++) perm[i] = i;

        double bestAcc = 0.0;
        int permNum = 1;

        do {
            int total = 0;
            int correct = 0;

            for (int i = 0; i < n; i++) {
                Map.Entry<String,Integer> e = entries.get(i);
                Integer cid = e.getValue();
                String trueLabel = trueLabels.get(i);

                Integer ci = clusterIdToIdx.get(cid);
                Integer li = labelToIdx.get(trueLabel);
                if (ci == null || li == null) continue;

                int predictedLabelIdx = perm[ci];
                if (predictedLabelIdx == li) correct++;
                total++;
            }

            double acc = total == 0 ? 0.0 : (correct / (double) total);

            // Print de la permutación
            StringBuilder sb = new StringBuilder();
            sb.append("Permutacion ").append(permNum).append(" -> ");
            for (int i = 0; i < K; i++) {
                int cid = clusterIds[i];
                int lblIdx = perm[i];
                String lblName = (lblIdx >= 0 && lblIdx < labelNames.length)
                        ? labelNames[lblIdx]
                        : ("idx=" + lblIdx);
                sb.append("cluster ").append(cid).append(" -> ").append(lblName);
                if (i + 1 < K) sb.append(", ");
            }
            sb.append(String.format(Locale.US, " | accuracy = %.4f", acc));
            System.out.println(sb);

            if (acc > bestAcc) bestAcc = acc;
            permNum++;
        } while (nextPermutation(perm));

        return bestAcc;
    }

    private static List<String> loadLabelsInOrder(Path path) throws IOException {
        List<String> lines = Files.readAllLines(path);
        // Nuevo formato fijo esperado:
        //  - línea 0: ids de preguntas
        //  - línea 1: tipos
        //  - línea 2: opciones
        //  - líneas 3..N: datos (última columna = etiqueta)
        if (lines.size() < 4) {
            throw new IOException("CSV demasiado corto: " + path);
        }

        int startRow = 3; // datos a partir de la cuarta línea

        List<String> labels = new ArrayList<>();
        for (int i = startRow; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line == null || line.isBlank()) continue;
            // normalizar posibles CR de Windows
            line = line.replace("\r", "");
            String[] cols = line.split(",", -1);
            if (cols.length == 0) continue;
            String label = cols[cols.length - 1].trim(); // ULTIMA columna
            if (label.isEmpty()) continue;
            labels.add(label);
        }
        return labels;
    }

    // Siguiente permutacion lexicografica sobre perm[]
    private static boolean nextPermutation(int[] a) {
        int n = a.length;
        int i = n - 2;
        while (i >= 0 && a[i] >= a[i + 1]) i--;
        if (i < 0) return false;
        int j = n - 1;
        while (a[j] <= a[i]) j--;
        swap(a, i, j);
        reverse(a, i + 1, n - 1);
        return true;
    }

    private static void swap(int[] a, int i, int j) {
        int tmp = a[i]; a[i] = a[j]; a[j] = tmp;
    }

    private static void reverse(int[] a, int i, int j) {
        while (i < j) swap(a, i++, j--);
    }
}
package edu.upc.prop.domain.classes.evaluation;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class Silhouette {
    private final Distance dist;
    public Silhouette(Distance dist){ this.dist = dist; }

    public double compute(ClusterResult res, List<Vectorizer.Point> data){
        Map<String, Vectorizer.Point> byId = new HashMap<>();
        for (var p: data) byId.put(p.id(), p);

        Map<Integer, List<Vectorizer.Point>> groups = new HashMap<>();
        for (var e: res.assignments().entrySet()){
            groups.computeIfAbsent(e.getValue(), k->new ArrayList<>()).add(byId.get(e.getKey()));
        }

        double total=0; int n=0;
        for (var p: data){
            int cid = res.assignments().get(p.id());
            double a = avgDist(p, groups.get(cid));
            double b = Double.POSITIVE_INFINITY;
            for (var entry: groups.entrySet()){
                if (entry.getKey()==cid) continue;
                b = Math.min(b, avgDist(p, entry.getValue()));
            }
            double s = (b - a) / Math.max(a, b);
            total += s; n++;
        }
        return n==0? 0 : total/n;
    }

    private double avgDist(Vectorizer.Point p, List<Vectorizer.Point> list){
        if (list==null || list.size()<=1) return 0;
        double s=0; int c=0;
        for (var q: list){
            if (q==p) continue;
            s += dist.dist(p, q); c++;
        }
        return c==0? 0 : s/c;
    }
}
package edu.upc.prop.domain.classes.evaluation;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.distance.Distance;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.util.*;

public class SSE {
    private final Distance dist;
    public SSE(Distance dist){ this.dist = dist; }

    public double compute(ClusterResult res, List<Vectorizer.Point> data){
        Map<String, Vectorizer.Point> byId = new HashMap<>();
        for (var p: data) byId.put(p.id(), p);

        double s=0;
        for (var e: res.assignments().entrySet()){
            var p = byId.get(e.getKey());
            var c = res.representatives().get(e.getValue());
            double d = dist.dist(p, c);
            s += d*d;
        }
        return s;
    }
}

package edu.upc.prop.domain.classes.vector;

import edu.upc.prop.domain.classes.model.ValorRespuesta;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

//definción de la clase
public class VectorSchema {
    private final Map<String, List<String>> oneHot = new LinkedHashMap<>();
    private final Map<String, double[]> numericRanges = new LinkedHashMap<>();
    private final Map<String, ValorRespuesta> defaultValues = new LinkedHashMap<>();
    private final Map <String, double[]> outlierLimits = new LinkedHashMap<>();
    private int dimensions;

    public void setOneHot(String questionId, List<String> options) {
        this.oneHot.put(questionId, List.copyOf(options));
    }

    public void setNumericRange(String questionId, double min, double max) {
        this.numericRanges.put(questionId, new double[]{min, max});
    }

    public void setDefaultValue(String questionId, ValorRespuesta valor) {
        System.out.println("DEBUG: Dado que la respuesta es nula o vacia para la pregunta '" + questionId + "', guardaremos como respuesta la media: " + valor);
        this.defaultValues.put(questionId, valor);
    }

    public ValorRespuesta getDefaultValue(String questionId) {
        return this.defaultValues.get(questionId);
    }

    public void setOutlierLimits(String questionId, double lowerLimit, double upperLimit) {
        this.outlierLimits.put(questionId, new double[]{lowerLimit, upperLimit});
    }

    public double[] getOutlierLimits(String questionId) {
        return this.outlierLimits.get(questionId);
    }

    public List<String> getOptions(String questionId) {
        return oneHot.getOrDefault(questionId, List.of());
    }

    public double[] getRange(String questionId) {
        return (double[])this.numericRanges.get(questionId);
    }

    public void setDimensions(int d) {
        this.dimensions = d;
    }

    public int getDimensions() {
        return this.dimensions;
    }
}package edu.upc.prop.domain.classes.vector;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.model.ValorRespuesta;
import edu.upc.prop.domain.classes.model.ValorRespuestaNumerica;
import edu.upc.prop.domain.classes.model.ValorRespuestaTextual;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionUnica;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionMultiple;

import java.util.*;

public class Vectorizer {

    // Punto = vectorizado de un participante
    public static class Point {
        private final String id;
        private final double[] values;
        private final boolean[] missing;
        public Point(String id, double[] values, boolean[] missing){
            this.id = id;
            this.values = values;
            this.missing = missing;
        }
        public String id(){ return id; }
        public double[] values(){ return values; }
        public boolean[] missing(){ return missing; }
    }

    private final VectorSchema schema = new VectorSchema();

    /**
     Ajusta el esquema de vectorizacion a partir de las respuestas:
     - Preguntas NUMERICAS: calcula el rango [min, max] observado para normalizar luego a [0,1].
     - Preguntas de TEXTO: detecta las categorias observadas y configura una codificacion one-hot.
     - OPCION_UNICA / OPCION_MULTIPLE: configura tambien sus categorias en el esquema (one-hot),
     Se hace un esquema que se utilizará despues en transform(...) para convertir cada Respuesta en un vector numerico.
     */
    public void fit(Cuestionario c, List<Respuesta> rs){
        List<Pregunta> preguntas = c.getPreguntas();
        if (preguntas.isEmpty()) {
            schema.setDimensions(0);
            return;
        }

        // empezamos en 1 para saltar la PRIMERA PREGUNTA (IDs)
        for (int idx = 1; idx < preguntas.size(); idx++) {
            Pregunta p = preguntas.get(idx);
            String qid = p.getId();
            if (p.getTipo() == TipoPregunta.NUMERICA) {
                List <Double> valoresNumericos = new ArrayList<>();

                for (Respuesta r : rs){
                    ValorRespuesta v = r.getValores().get(p.getId());
                    if (v instanceof ValorRespuestaNumerica n){
                        valoresNumericos.add(n.getValor());
                    }
                }


                double minValid = Double.POSITIVE_INFINITY;
                double maxValid = Double.NEGATIVE_INFINITY;

                if (!valoresNumericos.isEmpty()) {
                    Collections.sort(valoresNumericos);
                    int n = valoresNumericos.size();
                    int idxQ1 = (int) (valoresNumericos.size() * 0.25);
                    int idxQ3 = (int) (valoresNumericos.size() * 0.75);

                    double q1 = valoresNumericos.get(idxQ1);
                    double q3 = valoresNumericos.get(idxQ3);

                    double iqr = q3 - q1;
                    minValid = q1 - 1.5 * iqr;
                    maxValid = q3 + 1.5 * iqr;

                    schema.setOutlierLimits(qid, minValid, maxValid);
                }

                double min = Double.POSITIVE_INFINITY;
                double max = Double.NEGATIVE_INFINITY;
                double suma = 0;
                int count = 0;

                for (Double v : valoresNumericos){
                    if (v >= minValid && v <= maxValid){
                        if (v < min) min = v;
                        if (v > max) max = v;
                        suma += v;
                        count++;
                    }
                }

                if (min == Double.POSITIVE_INFINITY){
                    min = 0;
                    max = 1;
                }
                schema.setNumericRange(p.getId(), min, max);

                if (count > 0) {
                    double media = suma / count;
                    schema.setDefaultValue(p.getId(), new ValorRespuestaNumerica(media));
                }

            } else if (p.getTipo() == TipoPregunta.TEXTO
                    || p.getTipo() == TipoPregunta.OPCION_UNICA
                    || p.getTipo() == TipoPregunta.OPCION_MULTIPLE) {
                List<String> opts = (p.getOpciones() == null || p.getOpciones().isEmpty())
                        ? observedOptions(p.getId(), rs)
                        : p.getOpciones();
                schema.setOneHot(p.getId(), opts);
                if (p.getTipo() == TipoPregunta.OPCION_UNICA) {
                    Map <Integer,Integer> conteo = new HashMap<>();
                    for (Respuesta r : rs) {
                        ValorRespuesta v = r.getValores().get(p.getId());
                        if (v instanceof ValorRespuestaOpcionUnica vu) {
                            Integer indice = vu.getIndiceSeleccionado();
                            conteo.put(indice, conteo.getOrDefault(indice, 0) + 1);
                        }
                    }
                    int mejorIndice = -1;
                    int maxConteo = -1;
                    for (Map.Entry<Integer, Integer> entry : conteo.entrySet()) {
                        if (entry.getValue() > maxConteo) {
                            maxConteo = entry.getValue();
                            mejorIndice = entry.getKey();
                        }
                    }
                    if (mejorIndice != -1) {
                        schema.setDefaultValue(p.getId(), new ValorRespuestaOpcionUnica(mejorIndice));
                    }
                }
            }
        }

        // Calcular numero total de dimensiones (tambien saltando la primera pregunta)
        int dims = 0;
        for (int idx = 1; idx < preguntas.size(); idx++) {
            Pregunta p = preguntas.get(idx);
            switch (p.getTipo()){
                case NUMERICA -> dims += 1;
                case TEXTO, OPCION_UNICA, OPCION_MULTIPLE -> {
                    List<String> opts = schema.getOptions(p.getId());
                    dims += Math.max(1, opts.size());
                }
            }
        }
        schema.setDimensions(dims);
    }

    public Point transform(Respuesta r, Cuestionario c){
        double[] v = new double[schema.getDimensions()];
        boolean[] m = new boolean[schema.getDimensions()];
        int off = 0;

        List<Pregunta> preguntas = c.getPreguntas();
        if (preguntas.isEmpty()) {
            return new Point(r.getIdParticipante(), v, m);
        }

        // empezamos en 1 para saltar la PRIMERA PREGUNTA (IDs)
        for (int idx = 1; idx < preguntas.size(); idx++) {
            Pregunta p = preguntas.get(idx);
            ValorRespuesta val = r.getValores().get(p.getId());

            if (p.getTipo() == TipoPregunta.NUMERICA && val instanceof ValorRespuestaNumerica n) {
                double[] limits = schema.getOutlierLimits(p.getId());
                if (limits != null) {
                    double x = n.getValor();
                    if (x < limits[0] || x > limits[1]) {
                        val = null;
                    }
                }
            }

            if (val == null){
                val = schema.getDefaultValue(p.getId());
            }

            switch (p.getTipo()){
                case NUMERICA -> {
                    if (val instanceof ValorRespuestaNumerica n){
                        double[] rg = schema.getRange(p.getId());
                        double norm = (rg[1]-rg[0]) == 0
                                ? 0.5
                                : ((n.getValor() - rg[0]) / (rg[1]-rg[0]));
                        v[off] = clamp(norm);
                        m[off] = false;
                    } else {
                        v[off] = 0;
                        m[off] = true;
                    }
                    off += 1;
                }
                case TEXTO -> {
                    List<String> opts = schema.getOptions(p.getId());
                    String sVal = (val instanceof ValorRespuestaTextual vt) ? vt.getValor() : null;
                    if (opts.isEmpty()){
                        v[off] = 0.0;
                        m[off] = (sVal == null);
                        off += 1;
                    } else {
                        for (int i = 0; i < opts.size(); i++){
                            if (sVal != null && sVal.equals(opts.get(i))){
                                v[off + i] = 1.0;
                                m[off + i] = false;
                            } else {
                                v[off + i] = 0.0;
                                m[off + i] = (sVal == null);
                            }
                        }
                        off += opts.size();
                    }
                }
                case OPCION_UNICA -> {
                    var opts = schema.getOptions(p.getId());
                    Integer indice = (val instanceof ValorRespuestaOpcionUnica vu) ? vu.getIndiceSeleccionado() : null;
                    for (int i = 0; i < opts.size(); i++){
                        if (indice != null && indice == i) { // Comparar con el índice
                            v[off + i] = 1.0;
                            m[off + i] = false;
                        } else {
                            v[off + i] = 0.0;
                            m[off + i] = (indice == null);
                        }
                    }
                    off += opts.size();
                }
                case OPCION_MULTIPLE -> {
                    var opts = schema.getOptions(p.getId());
                    Set<Integer> indicesSeleccionados = new HashSet<>();
                    if (val instanceof ValorRespuestaOpcionMultiple vm){
                        indicesSeleccionados.addAll(vm.getIndicesSeleccionados());
                    }
                    int k = Math.max(1, indicesSeleccionados.size());
                    for (int i = 0; i < opts.size(); i++){
                        boolean on = indicesSeleccionados.contains(i);
                        v[off + i] = on ? (1.0 / k) : 0.0;
                        m[off + i] = indicesSeleccionados.isEmpty(); // Es missing si no se seleccionó nada
                    }
                    off += opts.size();
                }
            }
        }

        return new Point(r.getIdParticipante(), v, m);
    }

    public List<Point> transformAll(List<Respuesta> rs, Cuestionario c){
        List<Point> out = new ArrayList<>();
        for (Respuesta r : rs) out.add(transform(r, c));
        return out;
    }

    private static List<String> observedOptions(String id, List<Respuesta> rs){
        LinkedHashSet<String> set = new LinkedHashSet<>();
        for (Respuesta r : rs){
            ValorRespuesta v = r.getValores().get(id);
            if (v instanceof ValorRespuestaTextual s) {
                set.add(s.getValor()); // Usar getter
            }
        }
        return new ArrayList<>(set);
    }

    private static double clamp(double x){
        return Math.max(0, Math.min(1, x));
    }
}package edu.upc.prop.domain.controllers;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;

import java.util.Collection;


public class CtrlEncuesta {

    private final CtrlPersistencia ctrlPersistencia;

    public CtrlEncuesta(CtrlPersistencia ctrlPersistencia) {
        this.ctrlPersistencia = ctrlPersistencia;
    }


    public void crear(String id) {
        ctrlPersistencia.Ecreate(id);
    }

    public Cuestionario obtener(String id) {
        return ctrlPersistencia.Eget(id);
    }

    public Collection<Cuestionario> listar() {
        return ctrlPersistencia.Elist();
    }

    public void guardar(Cuestionario encuesta) {
        ctrlPersistencia.Eput(encuesta);
    }

    public boolean eliminar(String id) {
        return ctrlPersistencia.Edelete(id);
    }

    public boolean existe(String id) {
        return ctrlPersistencia.Eexists(id);
    }

    public void agregarPregunta(String idEncuesta, Pregunta p) {
        Cuestionario e = obtener(idEncuesta);
        if (e == null) throw new IllegalArgumentException("La encuesta no existe");
        e.addPregunta(p);
        guardar(e);
    }

    public boolean eliminarPregunta(String idEncuesta, String preguntaId) {
        Cuestionario e = obtener(idEncuesta);
        if (e == null) throw new IllegalArgumentException("La encuesta no existe");
        boolean eliminado = e.eliminarPregunta(preguntaId);
        if (eliminado) guardar(e);
        return eliminado;
    }
}package edu.upc.prop.domain.controllers;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.Usuario; // Importar Usuario
import edu.upc.prop.domain.classes.vector.Vectorizer;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class CtrlDominio {
    // Controladores especializados
    private final CtrlEncuesta ctrlEncuesta;
    private final CtrlRespuesta ctrlRespuesta;
    private final CtrlClustering ctrlClustering;

    // Referencia a persistencia para gestionar usuarios
    private final CtrlPersistencia ctrlPersistencia;

    // ESTADO DE LA SESIÓN
    private Usuario usuarioActual = null;

    public CtrlDominio(CtrlPersistencia ctrlPersistencia) {
        this.ctrlPersistencia = ctrlPersistencia;
        this.ctrlEncuesta = new CtrlEncuesta(ctrlPersistencia);
        this.ctrlRespuesta = new CtrlRespuesta(ctrlPersistencia);
        this.ctrlClustering = new CtrlClustering(ctrlPersistencia);
    }


    // GESTIÓN DE USUARIOS (LOGIN / REGISTRO)

    public void registrarUsuario(String email, String pass, String nombre, String ape, String nac) {
        if (ctrlPersistencia.Uexists(email)) {
            throw new IllegalArgumentException("El usuario ya existe.");
        }
        Usuario u = new Usuario(email, pass, nombre, ape, nac);
        ctrlPersistencia.Usave(u);
    }

    public boolean login(String email, String password) {
        if (!ctrlPersistencia.Uexists(email)) return false;

        Usuario u = ctrlPersistencia.Uget(email);
        if (u.checkPassword(password)) {
            this.usuarioActual = u;
            return true;
        }
        return false;
    }

    public void logout() {
        this.usuarioActual = null;
    }

    public String getUsuarioLogueadoNombre() {
        // Para la interfaz: Devuelve "nombre"
        return (usuarioActual != null) ? usuarioActual.getNombre() : "Invitado";
    }

    public String getUsuarioLogueadoEmail() {
        // Para la respuesta: Devuelve "nombre@mail.com"
        return (usuarioActual != null) ? usuarioActual.getEmail() : "anonimo";
    }

    public boolean estaLogueado() {
        return usuarioActual != null;
    }

    // MÉTODOS DE ENCUESTA
    public void crear(String id) {
        if (usuarioActual == null) throw new IllegalStateException("Debes iniciar sesión para crear encuestas.");

        // 1. Crear la encuesta base
        ctrlEncuesta.crear(id);

        // 2. Asignar el propietario inmediatamente
        Cuestionario c = ctrlEncuesta.obtener(id);
        c.setOwner(usuarioActual.getEmail());
        ctrlEncuesta.guardar(c);
    }


     //Guarda una encuesta. Si es una importación (owner es null), se la asigna al usuario actual.
    public void guardar(Cuestionario encuesta) {
        if (usuarioActual == null) throw new IllegalStateException("Debes iniciar sesión.");

        // Si la encuesta no tiene dueño (ej. importada), se la asignamos al usuario actual
        if (encuesta.getOwner() == null) {
            encuesta.setOwner(usuarioActual.getEmail());
        } else {
            // Protección: No guardar si intentas sobrescribir la de otro
            if (!encuesta.getOwner().equals(usuarioActual.getEmail())) {
                throw new SecurityException("No puedes modificar una encuesta que no es tuya.");
            }
        }
        ctrlEncuesta.guardar(encuesta);
    }

    public boolean eliminar(String id) {
        if (usuarioActual == null) return false;

        Cuestionario c = ctrlEncuesta.obtener(id);
        if (c != null) {
            // Solo permitir borrar si eres el dueño
            if (c.getOwner() != null && !c.getOwner().equals(usuarioActual.getEmail())) {
                throw new SecurityException("No puedes eliminar una encuesta de otro usuario.");
            }
        }
        return ctrlEncuesta.eliminar(id);
    }

    /**
     * Lista TODAS las encuestas del sistema.
     * USAR EN: Gestor de Respuestas (para verlas todas).
     */
    public Collection<Cuestionario> listar() {
        return ctrlEncuesta.listar();
    }

    /**
     * Lista SOLO las encuestas del usuario logueado.
     * USAR EN: Gestor de Encuestas (CRUD personal).
     */
    public Collection<Cuestionario> listarMisEncuestas() {
        if (usuarioActual == null) return new ArrayList<>();

        return ctrlEncuesta.listar().stream()
                .filter(c -> c.getOwner() != null && c.getOwner().equals(usuarioActual.getEmail()))
                .collect(Collectors.toList());
    }

    public Cuestionario obtener(String id) { return ctrlEncuesta.obtener(id); }
    public boolean existe(String id) { return ctrlEncuesta.existe(id); }

    // Delegación con protección de escritura
    public void agregarPregunta(String idEncuesta, Pregunta p) {
        verificarPropiedad(idEncuesta);
        ctrlEncuesta.agregarPregunta(idEncuesta, p);
    }

    public boolean eliminarPregunta(String idEncuesta, String preguntaId) {
        verificarPropiedad(idEncuesta);
        return ctrlEncuesta.eliminarPregunta(idEncuesta, preguntaId);
    }

    // Método para proteger modificaciones
    private void verificarPropiedad(String idEncuesta) {
        if (usuarioActual == null) throw new IllegalStateException("No hay sesión iniciada.");
        Cuestionario c = ctrlEncuesta.obtener(idEncuesta);
        if (c != null && c.getOwner() != null && !c.getOwner().equals(usuarioActual.getEmail())) {
            throw new SecurityException("Esta encuesta no te pertenece.");
        }
    }

    // MÉTODOS DE RESPUESTA
    public void agregar(String encuestaId, Respuesta r) { ctrlRespuesta.agregar(encuestaId, r); }
    public List<Respuesta> listarRespuestas(String encuestaId) { return ctrlRespuesta.listarRespuestas(encuestaId); }
    public boolean eliminarPorParticipante(String encuestaId, String participante) { return ctrlRespuesta.eliminarPorParticipante(encuestaId, participante); }
    public void eliminarTodas(String encuestaId) { ctrlRespuesta.eliminarTodas(encuestaId); }
    public int getSize(String encuestaId) { return ctrlRespuesta.getSize(encuestaId); }
    public void eliminarPreguntaR(String encuestaId, String preguntaId) { ctrlRespuesta.eliminarPreguntaR(encuestaId, preguntaId); }

    // MÉTODOS DE CLUSTERING
    public Cuestionario getEncuesta(String id) { return ctrlClustering.getEncuesta(id); }
    public int numRespuestas(String id) { return ctrlClustering.numRespuestas(id); }
    public ClusterResult getUltimoResultado() { return ctrlClustering.getUltimoResultado(); }
    public String getUltimoResultadoEncuestaId() { return ctrlClustering.getUltimoResultadoEncuestaId(); }
    public double getUltimoSse() { return ctrlClustering.getUltimoSse(); }
    public double getUltimoSilhouette() { return ctrlClustering.getUltimoSilhouette(); }
    public long getUltimoTiempoMs() { return ctrlClustering.getUltimoTiempoMs(); }
    public List<Vectorizer.Point> vectorizar(Cuestionario c) { return ctrlClustering.vectorizar(c); }
    public double[] evaluar(ClusterResult res, List<Vectorizer.Point> datos) { return ctrlClustering.evaluar(res, datos); }

    public ClusterResult ejecutarKMeans(Cuestionario c, int k, boolean kpp) {
        if(c.getOwner() != null && !c.getOwner().equals(usuarioActual.getEmail())) throw new SecurityException("Solo puedes clusterizar tus encuestas");
        return ctrlClustering.ejecutarKMeans(c, k, kpp);
    }

    public ClusterResult ejecutarKMedoids(Cuestionario c, int k) {
        return ctrlClustering.ejecutarKMedoids(c, k);
    }
    public List<Vectorizer.Point> calcularDatosUltimaEncuesta() { return ctrlClustering.calcularDatosUltimaEncuesta(); }
}package edu.upc.prop.domain.controllers;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.distance.GowerDistance;
import edu.upc.prop.domain.classes.clustering.KMedoids;
import edu.upc.prop.domain.classes.clustering.KMeans;
import edu.upc.prop.domain.classes.evaluation.SSE;
import edu.upc.prop.domain.classes.evaluation.Silhouette;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;
import edu.upc.prop.domain.classes.distance.Distance;

import java.util.List;


public class CtrlClustering {

    private final CtrlPersistencia ctrlPersistencia;
    private ClusterResult ultimoResultado;
    private String ultimoResultadoEncuestaId;

    private double ultimoSse = Double.NaN;
    private double ultimoSilhouette = Double.NaN;
    private long ultimoTiempoMs = -1;

    public CtrlClustering(CtrlPersistencia ctrlPersistencia) {
        this.ctrlPersistencia = ctrlPersistencia;
    }


    public Cuestionario getEncuesta(String id) {
        return ctrlPersistencia.Eget(id);
    }

    public int numRespuestas(String id) {
        return ctrlPersistencia.Rsize(id);
    }

    public ClusterResult getUltimoResultado() { return ultimoResultado; }
    public String getUltimoResultadoEncuestaId() { return ultimoResultadoEncuestaId; }
    public double getUltimoSse() { return ultimoSse; }
    public double getUltimoSilhouette() { return ultimoSilhouette; }
    public long getUltimoTiempoMs() { return ultimoTiempoMs; }

    public List<Vectorizer.Point> vectorizar(Cuestionario c) {
        var rs = ctrlPersistencia.Rall(c.getId());
        if (rs.isEmpty()) throw new IllegalStateException("No hay respuestas.");
        Vectorizer v = new Vectorizer();
        v.fit(c, rs);
        return v.transformAll(rs, c);
    }

    public double[] evaluar(ClusterResult res, List<Vectorizer.Point> datos) {
        if (res == null) {
            ultimoSse = Double.NaN;
            ultimoSilhouette = Double.NaN;
            return new double[]{Double.NaN, Double.NaN};
        }

        Distance dist = new GowerDistance();
        double sse = new SSE(dist).compute(res, datos);
        double sil = new Silhouette(dist).compute(res, datos);

        ultimoSse = sse;
        ultimoSilhouette = sil;

        return new double[]{sse, sil};
    }

    public ClusterResult ejecutarKMeans(Cuestionario c, int k, boolean kpp) {
        List<Vectorizer.Point> datos = vectorizar(c);
        var dist = new GowerDistance();
        var km = new KMeans();

        long t0 = System.nanoTime();
        ultimoResultado = km.run(datos, k, dist, kpp, 100);
        long t1 = System.nanoTime();

        ultimoTiempoMs = (t1 - t0) / 1_000_000L;
        ultimoResultadoEncuestaId  = c.getId();

        evaluar(ultimoResultado, datos);
        return ultimoResultado;
    }

    public ClusterResult ejecutarKMedoids(Cuestionario c, int k) {
        List<Vectorizer.Point> datos = vectorizar(c);
        var dist = new GowerDistance();
        var pam = new KMedoids();

        long t0 = System.nanoTime();
        ultimoResultado = pam.run(datos, k, dist, 50);
        long t1 = System.nanoTime();

        ultimoTiempoMs = (t1 - t0) / 1_000_000L;
        ultimoResultadoEncuestaId = c.getId();

        evaluar(ultimoResultado, datos);
        return ultimoResultado;
    }

    public List<Vectorizer.Point> calcularDatosUltimaEncuesta() {
        if (ultimoResultadoEncuestaId == null) return null;
        Cuestionario c = ctrlPersistencia.Eget(ultimoResultadoEncuestaId);
        if (c == null) return null;
        return vectorizar(c);
    }
}package edu.upc.prop.domain.controllers;

import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.persistence.controllers.CtrlPersistencia;

import java.util.List;


public class CtrlRespuesta {

    private final CtrlPersistencia ctrlPersistencia;

    public CtrlRespuesta(CtrlPersistencia ctrlPersistencia) {
        this.ctrlPersistencia = ctrlPersistencia;
    }


    public void agregar(String encuestaId, Respuesta r) {
        ctrlPersistencia.Radd(encuestaId, r);
    }

    public List<Respuesta> listarRespuestas(String encuestaId) {
        return ctrlPersistencia.Rall(encuestaId);
    }

    public boolean eliminarPorParticipante(String encuestaId, String participante) {
        return ctrlPersistencia.RremoveById(encuestaId, participante);
    }

    public void eliminarTodas(String encuestaId) {
        ctrlPersistencia.Rclear(encuestaId);
    }

    public int getSize(String encuestaId) {
        return ctrlPersistencia.Rsize(encuestaId);
    }

    public void eliminarPreguntaR(String encuestaId, String preguntaId) {
        ctrlPersistencia.RremoveQuestion(encuestaId, preguntaId);
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class PanelEncuestas extends JPanel {

    private CtrlPresentacion ctrlPresentacion;

    private JList<String> listaEncuestas;
    private DefaultListModel<String> listModel;
    private JTable tablaPreguntas;
    private DefaultTableModel tableModel;
    private JLabel lblTituloDetalle;

    public PanelEncuestas(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        inicializarComponentes();
        recargarLista();
    }

    private void inicializarComponentes() {
        this.setLayout(new BorderLayout(10, 10));
        this.setBorder(new EmptyBorder(20, 20, 20, 20));

        // Título
        JLabel titulo = new JLabel("Gestor de Encuestas", SwingConstants.CENTER);
        titulo.setFont(new Font("Arial", Font.BOLD, 24));
        titulo.setForeground(new Color(0, 102, 204));
        this.add(titulo, BorderLayout.NORTH);

        // Panel dividido
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
        splitPane.setResizeWeight(0.3);

        // Zona izquierda: Lista
        JPanel panelIzquierdo = new JPanel(new BorderLayout(5, 5));
        panelIzquierdo.setBorder(BorderFactory.createTitledBorder("Encuestas Disponibles"));

        listModel = new DefaultListModel<>();

        // --- CAMBIO PASO 3: JList con Tooltip dinámico ---
        listaEncuestas = new JList<>(listModel) {
            @Override
            public String getToolTipText(java.awt.event.MouseEvent e) {
                int index = locationToIndex(e.getPoint());
                if (index > -1) {
                    Object item = getModel().getElementAt(index);
                    return item.toString(); // Muestra el nombre de la encuesta
                }
                return null;
            }
        };
        // -------------------------------------------------

        listaEncuestas.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        listaEncuestas.addListSelectionListener(e -> mostrarDetallesSeleccion());

        panelIzquierdo.add(new JScrollPane(listaEncuestas), BorderLayout.CENTER);

        // Botones izquierda
        JPanel panelBotonesEnc = new JPanel(new GridLayout(1, 2, 5, 0));
        JButton btnCrear = new JButton("Crear Nueva");
        btnCrear.addActionListener(e -> crearEncuesta());
        JButton btnEliminar = new JButton("Eliminar");
        btnEliminar.setForeground(Color.RED);
        btnEliminar.addActionListener(e -> eliminarEncuesta());

        panelBotonesEnc.add(btnCrear);
        panelBotonesEnc.add(btnEliminar);
        panelIzquierdo.add(panelBotonesEnc, BorderLayout.SOUTH);

        // Zona derecha: Tabla preguntas
        JPanel panelDerecho = new JPanel(new BorderLayout(5, 5));
        lblTituloDetalle = new JLabel("Selecciona una encuesta para ver detalles");
        lblTituloDetalle.setFont(new Font("Arial", Font.ITALIC, 14));
        panelDerecho.add(lblTituloDetalle, BorderLayout.NORTH);

        String[] columnas = {"ID Pregunta", "Tipo", "Opciones / Config"};
        tableModel = new DefaultTableModel(columnas, 0) {
            @Override
            public boolean isCellEditable(int row, int column) { return false; }
        };

        // --- CAMBIO PASO 3: JTable con Tooltip dinámico por celda ---
        tablaPreguntas = new JTable(tableModel) {
            @Override
            public String getToolTipText(java.awt.event.MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int rowIndex = rowAtPoint(p);
                int colIndex = columnAtPoint(p);
                try {
                    if (rowIndex >= 0 && colIndex >= 0) {
                        Object val = getValueAt(rowIndex, colIndex);
                        if (val != null) {
                            tip = val.toString(); // Muestra el contenido de la celda
                        }
                    }
                } catch (RuntimeException e1) { }
                return tip;
            }
        };
        // -----------------------------------------------------------

        // FUNCIONALIDAD: Doble clic para ver detalle de la pregunta/opciones
        tablaPreguntas.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                if (evt.getClickCount() == 2) {
                    int row = tablaPreguntas.rowAtPoint(evt.getPoint());
                    int col = tablaPreguntas.columnAtPoint(evt.getPoint());

                    if (row >= 0 && col >= 0) {
                        Object valor = tablaPreguntas.getValueAt(row, col);
                        if (valor != null) {
                            verTextoCompleto(valor.toString());
                        }
                    }
                }
            }
        });

        panelDerecho.add(new JScrollPane(tablaPreguntas), BorderLayout.CENTER);

        // Botones derecha
        JPanel panelBotonesPreg = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton btnAddPregunta = new JButton("Añadir Pregunta...");
        btnAddPregunta.addActionListener(e -> agregarPreguntaCompleta());
        JButton btnDelPregunta = new JButton("Eliminar Pregunta");
        btnDelPregunta.addActionListener(e -> eliminarPregunta());

        panelBotonesPreg.add(btnAddPregunta);
        panelBotonesPreg.add(btnDelPregunta);
        panelDerecho.add(panelBotonesPreg, BorderLayout.SOUTH);

        splitPane.setLeftComponent(panelIzquierdo);
        splitPane.setRightComponent(panelDerecho);
        this.add(splitPane, BorderLayout.CENTER);

        // BOTÓN VOLVER (Asegurado)
        JPanel panelSur = new JPanel(new FlowLayout(FlowLayout.CENTER));
        JButton btnVolver = new JButton("<< Volver al Menú Principal");
        btnVolver.setFont(new Font("Arial", Font.BOLD, 12));
        // Llama a cambiarVista usando la constante del menú
        btnVolver.addActionListener(e -> ctrlPresentacion.cambiarVista(VistaPrincipal.VISTA_MENU));

        panelSur.add(btnVolver);
        this.add(panelSur, BorderLayout.SOUTH);

        // Esto ya lo tenías, y se encarga de los botones estáticos y labels
        GuiUtils.asignarTooltipsGlobales(this);
    }

    // Cargar lista desde controlador
    public void recargarLista() {
        listModel.clear();
        for (String id : ctrlPresentacion.obtenerIdsEncuestas()) {
            listModel.addElement(id);
        }
        tableModel.setRowCount(0);
        lblTituloDetalle.setText("Selecciona una encuesta...");
    }

    private void mostrarDetallesSeleccion() {
        String idSeleccionado = listaEncuestas.getSelectedValue();
        if (idSeleccionado == null) return;

        lblTituloDetalle.setText("Detalles de: " + idSeleccionado);
        tableModel.setRowCount(0);

        Cuestionario c = ctrlPresentacion.getCtrlDominio().obtener(idSeleccionado);
        if (c != null) {
            for (Pregunta p : c.getPreguntas()) {
                String config = "";
                if (p.getTipo() == TipoPregunta.OPCION_UNICA || p.getTipo() == TipoPregunta.OPCION_MULTIPLE) {
                    config = String.join("|", p.getOpciones());
                    if (p.getTipo() == TipoPregunta.OPCION_MULTIPLE) config += " (Max: " + p.getMaxSeleccion() + ")";
                }
                tableModel.addRow(new Object[]{p.getId(), p.getTipo(), config});
            }
        }
    }

    // Operaciones
    private void crearEncuesta() {
        String id = JOptionPane.showInputDialog(this, "Introduce el ID de la nueva encuesta:", "Crear Encuesta", JOptionPane.QUESTION_MESSAGE);
        if (id != null && !id.trim().isEmpty()) {
            try {
                ctrlPresentacion.getCtrlDominio().crear(id.trim());
                recargarLista();
                JOptionPane.showMessageDialog(this, "Encuesta creada con éxito.");
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Error: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void eliminarEncuesta() {
        String id = listaEncuestas.getSelectedValue();
        if (id == null) {
            JOptionPane.showMessageDialog(this, "Selecciona una encuesta primero.");
            return;
        }
        int confirm = JOptionPane.showConfirmDialog(this, "¿Seguro que quieres borrar '" + id + "' y todas sus respuestas?", "Confirmar", JOptionPane.YES_NO_OPTION);
        if (confirm == JOptionPane.YES_OPTION) {
            ctrlPresentacion.getCtrlDominio().eliminar(id);
            ctrlPresentacion.getCtrlDominio().eliminarTodas(id);
            recargarLista();
        }
    }

    private void agregarPreguntaCompleta() {
        String idEncuesta = listaEncuestas.getSelectedValue();
        if (idEncuesta == null) {
            JOptionPane.showMessageDialog(this, "Selecciona una encuesta primero.");
            return;
        }

        // Formulario
        JTextField txtEnunciado = new JTextField();
        JComboBox<TipoPregunta> comboTipo = new JComboBox<>(TipoPregunta.values());

        JTextArea txtOpciones = new JTextArea(3, 20);
        txtOpciones.setLineWrap(true);
        txtOpciones.setToolTipText("Ej: Rojo|Verde|Azul");
        JScrollPane scrollOpciones = new JScrollPane(txtOpciones);

        txtOpciones.setEnabled(false);
        txtOpciones.setBackground(SystemColor.control);

        JSpinner spinMax = new JSpinner(new SpinnerNumberModel(0, 0, 100, 1));
        spinMax.setEnabled(false);

        JPanel panelForm = new JPanel(new GridLayout(0, 1, 5, 5));
        panelForm.add(new JLabel("Enunciado (ID):"));
        panelForm.add(txtEnunciado);

        panelForm.add(new JLabel("Tipo de Pregunta:"));
        panelForm.add(comboTipo);

        panelForm.add(new JLabel("Opciones (separadas por '|'):"));
        panelForm.add(scrollOpciones);

        panelForm.add(new JLabel("Máx. Selecciones (0 = sin límite, solo Mult.):"));
        panelForm.add(spinMax);

        // Listener para activar campos
        comboTipo.addActionListener(e -> {
            TipoPregunta tipo = (TipoPregunta) comboTipo.getSelectedItem();
            boolean usaOpciones = (tipo == TipoPregunta.OPCION_UNICA || tipo == TipoPregunta.OPCION_MULTIPLE);
            boolean esMultiple = (tipo == TipoPregunta.OPCION_MULTIPLE);

            txtOpciones.setEnabled(usaOpciones);
            txtOpciones.setBackground(usaOpciones ? Color.WHITE : SystemColor.control);

            spinMax.setEnabled(esMultiple);
        });

        comboTipo.setSelectedItem(TipoPregunta.TEXTO);

        int result = JOptionPane.showConfirmDialog(this, panelForm,
                "Nueva Pregunta para " + idEncuesta, JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

        if (result == JOptionPane.OK_OPTION) {
            String enun = txtEnunciado.getText().trim();
            if (enun.isEmpty()) {
                JOptionPane.showMessageDialog(this, "El enunciado no puede estar vacío.");
                return;
            }

            TipoPregunta tipo = (TipoPregunta) comboTipo.getSelectedItem();
            List<String> listaOpciones = new ArrayList<>();
            int maxSel = 0;

            if (tipo == TipoPregunta.OPCION_UNICA || tipo == TipoPregunta.OPCION_MULTIPLE) {
                String rawOpciones = txtOpciones.getText().trim();
                if (rawOpciones.isEmpty()) {
                    JOptionPane.showMessageDialog(this, "Para este tipo de pregunta debes escribir opciones (separadas por '|').");
                    return;
                }

                String[] partes = rawOpciones.split("\\|");
                for (String p : partes) {
                    if (!p.trim().isEmpty()) {
                        listaOpciones.add(p.trim());
                    }
                }

                if (tipo == TipoPregunta.OPCION_MULTIPLE) {
                    maxSel = (Integer) spinMax.getValue();
                }
            }

            try {
                Pregunta p = new Pregunta(enun, enun, tipo, listaOpciones, maxSel);
                ctrlPresentacion.getCtrlDominio().agregarPregunta(idEncuesta, p);

                mostrarDetallesSeleccion();
                JOptionPane.showMessageDialog(this, "Pregunta añadida correctamente.");

            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, "Error al crear pregunta: " + e.getMessage());
            }
        }
    }

    private void eliminarPregunta() {
        String idEncuesta = listaEncuestas.getSelectedValue();
        int filaTabla = tablaPreguntas.getSelectedRow();

        if (idEncuesta == null || filaTabla == -1) {
            JOptionPane.showMessageDialog(this, "Selecciona una encuesta y una pregunta.");
            return;
        }

        String idPregunta = (String) tableModel.getValueAt(filaTabla, 0);

        int confirm = JOptionPane.showConfirmDialog(this, "¿Borrar pregunta '" + idPregunta + "'?", "Confirmar", JOptionPane.YES_NO_OPTION);
        if (confirm == JOptionPane.YES_OPTION) {
            ctrlPresentacion.getCtrlDominio().eliminarPregunta(idEncuesta, idPregunta);
            ctrlPresentacion.getCtrlDominio().eliminarPregunta(idEncuesta, idPregunta);
            mostrarDetallesSeleccion();
        }
    }

    private void verTextoCompleto(String texto) {
        JTextArea textArea = new JTextArea(texto);
        textArea.setRows(8);
        textArea.setColumns(40);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        textArea.setFont(new Font("SansSerif", Font.PLAIN, 14));

        JScrollPane scrollPane = new JScrollPane(textArea);
        JOptionPane.showMessageDialog(this, scrollPane, "Detalle Completo", JOptionPane.INFORMATION_MESSAGE);
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import java.awt.*;

public class VistaPrincipal {

    private CtrlPresentacion ctrlPresentacion;
    private JFrame frame;
    private JPanel panelContenedor;
    private CardLayout cardLayout;

    // Referencias a los paneles
    private PanelLogin panelLogin; // <--- NUEVO
    private PanelEncuestas panelEncuestas;
    private PanelRespuestas panelRespuestas;
    private PanelClustering panelClustering;

    private JTextArea logArea;

    // Constantes de navegación
    public static final String VISTA_LOGIN = "LOGIN"; // <--- NUEVO
    public static final String VISTA_MENU = "MENU";
    public static final String VISTA_ENCUESTAS = "ENCUESTAS";
    public static final String VISTA_RESPUESTAS = "RESPUESTAS";
    public static final String VISTA_CLUSTERING = "CLUSTERING";
    public static final String VISTA_DATOS = "DATOS";

    public VistaPrincipal(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        inicializarComponentes();
    }

    private void inicializarComponentes() {
        frame = new JFrame("System Survey & Clustering - PROP");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1000, 750); // Un poco más alto para que quepa todo bien
        frame.setLocationRelativeTo(null);

        cardLayout = new CardLayout();
        panelContenedor = new JPanel(cardLayout);

        // LOGIN (Lo primero que añadimos)
        this.panelLogin = new PanelLogin(ctrlPresentacion);
        panelContenedor.add(this.panelLogin, VISTA_LOGIN);

        // RESTO DE PANELES
        panelContenedor.add(crearPanelMenu(), VISTA_MENU);

        this.panelRespuestas = new PanelRespuestas(ctrlPresentacion);
        panelContenedor.add(this.panelRespuestas, VISTA_RESPUESTAS);

        this.panelClustering = new PanelClustering(ctrlPresentacion);
        panelContenedor.add(this.panelClustering, VISTA_CLUSTERING);

        // Gestor de Datos
        panelContenedor.add(new PanelDatos(ctrlPresentacion), VISTA_DATOS);

        // Gestor de Encuestas
        this.panelEncuestas = new PanelEncuestas(ctrlPresentacion);
        panelContenedor.add(this.panelEncuestas, VISTA_ENCUESTAS);

        frame.add(panelContenedor, BorderLayout.CENTER);

        crearPanelLog();

        //Arrancar mostrando el LOGIN
        cardLayout.show(panelContenedor, VISTA_LOGIN);
    }

    public void entrarAlSistema() {
        log("Acceso concedido. Bienvenido/a " + ctrlPresentacion.getUsuarioNombre());
        mostrarPanel(VISTA_MENU);
        frame.revalidate();
    }

    public void salirAlLogin() {
        log("Sesión cerrada.");
        mostrarPanel(VISTA_LOGIN);
    }


    private void crearPanelLog() {
        logArea = new JTextArea(5, 20);
        logArea.setEditable(false);
        logArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        logArea.append(">> Sistema iniciado. Identifíquese por favor...\n");
        JScrollPane scrollLog = new JScrollPane(logArea);
        scrollLog.setBorder(BorderFactory.createTitledBorder("Consola de Sistema"));

        frame.add(scrollLog, BorderLayout.SOUTH);
    }

    private JPanel crearPanelMenu() {
        JPanel panel = new JPanel(new GridLayout(2, 2, 20, 20));
        panel.setBorder(BorderFactory.createEmptyBorder(50, 50, 50, 50));

        panel.add(crearBotonMenu("Gestor Encuestas", VISTA_ENCUESTAS, new Color(173, 216, 230)));
        panel.add(crearBotonMenu("Gestor Respuestas", VISTA_RESPUESTAS, new Color(144, 238, 144)));
        panel.add(crearBotonMenu("Clustering", VISTA_CLUSTERING, new Color(255, 228, 181)));
        panel.add(crearBotonMenu("Gestor de Datos", VISTA_DATOS, new Color(221, 160, 221)));

        JPanel panelTotal = new JPanel(new BorderLayout());
        JLabel titulo = new JLabel("Bienvenido al Sistema de Clustering", SwingConstants.CENTER);
        titulo.setFont(new Font("Arial", Font.BOLD, 24));
        titulo.setBorder(BorderFactory.createEmptyBorder(20,0,0,0));

        // Panel inferior con botones de Salir y Logout
        JPanel panelBotones = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 10));

        JButton btnLogout = new JButton("Cerrar Sesión");
        btnLogout.setBackground(new Color(255, 100, 100)); // Rojo claro
        btnLogout.setForeground(Color.WHITE);
        btnLogout.addActionListener(e -> ctrlPresentacion.logout());

        JButton btnSalir = new JButton("Salir del Escritorio");
        btnSalir.addActionListener(e -> System.exit(0));

        panelBotones.add(btnLogout);
        panelBotones.add(btnSalir);

        panelTotal.add(titulo, BorderLayout.NORTH);
        panelTotal.add(panel, BorderLayout.CENTER);
        panelTotal.add(panelBotones, BorderLayout.SOUTH);

        //Tooltip
        GuiUtils.asignarTooltipsGlobales(panelTotal);

        return panelTotal;
    }

    private JButton crearBotonMenu(String texto, String vistaDestino, Color colorFondo) {
        JButton btn = new JButton(texto);
        btn.setFont(new Font("Arial", Font.BOLD, 18));
        btn.setBackground(colorFondo);
        btn.setFocusPainted(false);
        btn.addActionListener(e -> mostrarPanel(vistaDestino));
        return btn;
    }

    public void mostrarPanel(String nombreVista) {
        cardLayout.show(panelContenedor, nombreVista);

        // Actualizar vistas al entrar
        if (nombreVista.equals(VISTA_RESPUESTAS) && panelRespuestas != null) {
            panelRespuestas.alMostrar();
        }
        // Ahora PanelEncuestas cargará solo encuestas usuario
        if (nombreVista.equals(VISTA_ENCUESTAS) && panelEncuestas != null) {
            panelEncuestas.recargarLista();
        }
        if (nombreVista.equals(VISTA_CLUSTERING) && panelClustering != null) {
            panelClustering.alMostrar();
        }
    }

    public void hacerVisible() {
        frame.setVisible(true);
    }

    public void log(String mensaje) {
        if (logArea != null) {
            logArea.append(">> " + mensaje + "\n");
            logArea.setCaretPosition(logArea.getDocument().getLength());
        }
    }

    public void mostrarError(String titulo, String msg) {
        JOptionPane.showMessageDialog(frame, msg, titulo, JOptionPane.ERROR_MESSAGE);
    }
    public void mostrarInfo(String titulo, String msg) {
        JOptionPane.showMessageDialog(frame, msg, titulo, JOptionPane.INFORMATION_MESSAGE);
    }
}package edu.upc.prop.presentation.classes;

import javax.swing.*;
import java.awt.*;

public class GuiUtils {

    /**
     * Recorre recursivamente todos los componentes de un contenedor.
     * Si encuentra una etiqueta o botón sin tooltip, le asigna su propio texto como tooltip.
     */
    public static void asignarTooltipsGlobales(Container container) {
        for (Component c : container.getComponents()) {

            // 1. Si es JLabel
            if (c instanceof JLabel) {
                JLabel lbl = (JLabel) c;
                if (lbl.getToolTipText() == null && lbl.getText() != null && !lbl.getText().isEmpty()) {
                    // Quitamos etiquetas HTML si las hay para el tooltip simple, o lo dejamos tal cual
                    lbl.setToolTipText(lbl.getText().replaceAll("<[^>]*>", ""));
                }
            }

            // 2. Si es JButton
            else if (c instanceof JButton) {
                JButton btn = (JButton) c;
                // Solo asignamos si no tiene uno ya (para no sobrescribir los específicos de lógica)
                if (btn.getToolTipText() == null && btn.getText() != null && !btn.getText().isEmpty()) {
                    btn.setToolTipText(btn.getText());
                }
            }

            // 3. Si es CheckBox o RadioButton
            else if (c instanceof JToggleButton) {
                JToggleButton btn = (JToggleButton) c;
                if (btn.getToolTipText() == null && btn.getText() != null) {
                    btn.setToolTipText(btn.getText());
                }
            }

            // 4. RECURSIVIDAD: Si el componente es un panel o contenedor, entramos dentro
            if (c instanceof Container) {
                asignarTooltipsGlobales((Container) c);
            }
        }
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.domain.classes.model.*;
import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.List;
import java.util.ArrayList;

public class PanelRespuestas extends JPanel {

    private CtrlPresentacion ctrlPresentacion;

    private JComboBox<String> selectorMisEncuestas;
    private JTable tablaRespuestas;
    private DefaultTableModel tableModel;
    private JLabel lblTotal;

    public PanelRespuestas(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(15, 15, 15, 15));

        inicializarComponentes();
    }

    private void inicializarComponentes() {
        // --- 1. Panel Superior ---
        JPanel panelNorte = new JPanel(new BorderLayout());
        JPanel panelIzq = new JPanel(new FlowLayout(FlowLayout.LEFT));
        panelIzq.add(new JLabel("Ver respuestas de mi encuesta:"));

        selectorMisEncuestas = new JComboBox<>();
        selectorMisEncuestas.setPreferredSize(new Dimension(250, 25));
        selectorMisEncuestas.addActionListener(e -> cargarDatosEnTabla());
        panelIzq.add(selectorMisEncuestas);

        panelNorte.add(panelIzq, BorderLayout.WEST);

        JButton btnResponder = new JButton("Responder Encuestas");
        btnResponder.setBackground(new Color(100, 149, 237));
        btnResponder.setForeground(Color.WHITE);
        btnResponder.setFont(new Font("Arial", Font.BOLD, 12));
        btnResponder.setFocusPainted(false);
        btnResponder.addActionListener(e -> abrirDialogoResponder());

        panelNorte.add(btnResponder, BorderLayout.EAST);
        add(panelNorte, BorderLayout.NORTH);

        // --- 2. Panel Central (Tabla Mejorada) ---
        tableModel = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false; // Hacemos que no sea editable
            }
        };

        // Creamos la tabla sobrescribiendo prepareRenderer para los TOOLTIPS
        tablaRespuestas = new JTable(tableModel) {
            @Override
            public String getToolTipText(java.awt.event.MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int rowIndex = rowAtPoint(p);
                int colIndex = columnAtPoint(p);

                try {
                    // Si hay texto en la celda, lo mostramos en el tooltip
                    if (rowIndex >= 0 && colIndex >= 0) {
                        Object val = getValueAt(rowIndex, colIndex);
                        if (val != null && !val.toString().isEmpty()) {
                            tip = "<html><p width=\"300\">" + val.toString() + "</p></html>";
                        }
                    }
                } catch (RuntimeException e1) {
                    // Ignorar errores puntuales de renderizado
                }
                return tip;
            }
        };

        // Configuración visual
        tablaRespuestas.setRowHeight(25); // Filas un poco más altas
        tablaRespuestas.getTableHeader().setReorderingAllowed(false);

        // FUNCIONALIDAD: Doble clic para ver texto completo
        tablaRespuestas.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                // Solo si es doble clic (para no molestar al seleccionar)
                if (evt.getClickCount() == 2) {
                    int row = tablaRespuestas.rowAtPoint(evt.getPoint());
                    int col = tablaRespuestas.columnAtPoint(evt.getPoint());

                    if (row >= 0 && col >= 0) {
                        Object valor = tablaRespuestas.getValueAt(row, col);
                        if (valor != null) {
                            verTextoCompleto(valor.toString());
                        }
                    }
                }
            }
        });

        JScrollPane scroll = new JScrollPane(tablaRespuestas);
        scroll.setBorder(BorderFactory.createTitledBorder("Listado de Respuestas Recibidas"));

        // Scroll horizontal suave
        scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);

        add(scroll, BorderLayout.CENTER);

        // --- 3. Panel Inferior ---
        JPanel panelSur = new JPanel(new BorderLayout());
        JPanel panelInfo = new JPanel(new FlowLayout(FlowLayout.LEFT));
        lblTotal = new JLabel("Total respuestas: 0");
        panelInfo.add(lblTotal);

        JPanel panelVolver = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton btnVolver = new JButton("<< Volver al Menú");
        btnVolver.addActionListener(e -> ctrlPresentacion.cambiarVista(VistaPrincipal.VISTA_MENU));
        panelVolver.add(btnVolver);

        panelSur.add(panelInfo, BorderLayout.WEST);
        panelSur.add(panelVolver, BorderLayout.EAST);
        add(panelSur, BorderLayout.SOUTH);

        //Tooltip
        GuiUtils.asignarTooltipsGlobales(this);
    }

    public void alMostrar() {
        recargarSelector();
    }

    private void abrirDialogoResponder() {
        Frame parent = (Frame) SwingUtilities.getWindowAncestor(this);
        DialogoResponder dialogo = new DialogoResponder(parent, ctrlPresentacion);
        dialogo.setVisible(true);
        cargarDatosEnTabla();
    }

    private void recargarSelector() {
        selectorMisEncuestas.removeAllItems();
        List<String> misIds = ctrlPresentacion.obtenerIdsMisEncuestas();

        if (misIds.isEmpty()) {
            selectorMisEncuestas.addItem("No tienes encuestas creadas");
            selectorMisEncuestas.setEnabled(false);
        } else {
            selectorMisEncuestas.setEnabled(true);
            for (String id : misIds) {
                selectorMisEncuestas.addItem(id);
            }
            selectorMisEncuestas.setSelectedIndex(0);
        }
    }

    private void cargarDatosEnTabla() {
        tableModel.setRowCount(0);
        tableModel.setColumnCount(0);

        String idSeleccionado = (String) selectorMisEncuestas.getSelectedItem();
        if (idSeleccionado == null || idSeleccionado.equals("No tienes encuestas creadas")) {
            lblTotal.setText("Total respuestas: 0");
            return;
        }

        Cuestionario c = ctrlPresentacion.obtenerEncuesta(idSeleccionado);
        if (c == null) return;
        List<Pregunta> preguntas = c.getPreguntas();

        // --- Definir Columnas ---
        tableModel.addColumn("Participante");
        for (Pregunta p : preguntas) {
            tableModel.addColumn(p.getId());
        }

        // --- Lógica de Auto-ajuste de columnas ---
        // Si hay pocas columnas (ej: < 6), dejamos que la tabla ocupe todo el ancho (AUTO_RESIZE_ALL_COLUMNS)
        // Si hay muchas, activamos el scroll horizontal (AUTO_RESIZE_OFF) para que no se apiñen
        if (preguntas.size() < 6) {
            tablaRespuestas.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        } else {
            tablaRespuestas.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
            // Ajustamos anchos mínimos para que se lea bien
            tablaRespuestas.getColumnModel().getColumn(0).setPreferredWidth(150); // Participante más ancho
            for (int i = 1; i < tablaRespuestas.getColumnCount(); i++) {
                tablaRespuestas.getColumnModel().getColumn(i).setPreferredWidth(120);
            }
        }

        // --- Obtener Datos ---
        List<Respuesta> respuestas = ctrlPresentacion.listarRespuestas(idSeleccionado);
        lblTotal.setText("Total respuestas: " + respuestas.size());

        if (respuestas.isEmpty()) return;

        for (Respuesta r : respuestas) {
            Object[] fila = new Object[preguntas.size() + 1];
            fila[0] = r.getIdParticipante();

            for (int i = 0; i < preguntas.size(); i++) {
                Pregunta p = preguntas.get(i);
                ValorRespuesta val = r.getValores().get(p.getId());
                String textoAMostrar = "";

                if (val != null) {
                    if (val instanceof ValorRespuestaOpcionUnica && (p.getTipo() == TipoPregunta.OPCION_UNICA)) {
                        try {
                            int indice = ((ValorRespuestaOpcionUnica) val).getIndiceSeleccionado();
                            if (indice >= 0 && indice < p.getOpciones().size()) {
                                textoAMostrar = p.getOpciones().get(indice);
                            } else {
                                textoAMostrar = String.valueOf(indice);
                            }
                        } catch (Exception ex) { textoAMostrar = val.toString(); }
                    } else if (val instanceof ValorRespuestaOpcionMultiple && (p.getTipo() == TipoPregunta.OPCION_MULTIPLE)) {
                        try {
                            java.util.Collection<Integer> indices = ((ValorRespuestaOpcionMultiple) val).getIndicesSeleccionados();
                            List<String> textos = new ArrayList<>();
                            for (Integer idx : indices) {
                                if (idx >= 0 && idx < p.getOpciones().size()) {
                                    textos.add(p.getOpciones().get(idx));
                                }
                            }
                            textoAMostrar = String.join(", ", textos);
                        } catch (Exception ex) { textoAMostrar = val.toString(); }
                    } else {
                        textoAMostrar = val.toString();
                    }
                }
                fila[i + 1] = textoAMostrar;
            }
            tableModel.addRow(fila);
        }
    }

    // Método auxiliar para mostrar la ventana emergente
    private void verTextoCompleto(String texto) {
        JTextArea textArea = new JTextArea(texto);
        textArea.setRows(10);
        textArea.setColumns(50);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        textArea.setFont(new Font("SansSerif", Font.PLAIN, 14));

        JScrollPane scrollPane = new JScrollPane(textArea);

        JOptionPane.showMessageDialog(this, scrollPane, "Contenido Completo", JOptionPane.INFORMATION_MESSAGE);
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Pregunta;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.model.TipoPregunta;
import edu.upc.prop.domain.classes.model.ValorRespuesta;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionMultiple;
import edu.upc.prop.domain.classes.model.ValorRespuestaOpcionUnica;
import edu.upc.prop.domain.classes.vector.Vectorizer;
import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.TitledBorder;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class PanelClustering extends JPanel {

    private CtrlPresentacion ctrlPresentacion;
    private JComboBox<String> comboEncuestas;
    private JComboBox<String> comboAlgoritmo;
    private JSpinner spinK;
    private JButton btnEjecutar;
    private JPanel panelMetricas;
    private JLabel lblResumenMetricas;
    private JTable tablaResultados;
    private DefaultTableModel tableModel;
    private JButton btnExportarRes;
    private JButton btnAccuracy;
    private JButton btnGrafica;

    public PanelClustering(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        inicializarComponentes();
    }

    public void alMostrar() {
        recargarComboEncuestas();
        lblResumenMetricas.setText("Ejecuta un algoritmo para ver los resultados.");
        tableModel.setRowCount(0);
        tableModel.setColumnCount(0);
        actualizarEstadoBotones();
    }

    private void inicializarComponentes() {
        this.setLayout(new BorderLayout(10, 10));
        this.setBorder(new EmptyBorder(20, 20, 20, 20));

        JLabel titulo = new JLabel("Clustering y Análisis", SwingConstants.CENTER);
        titulo.setFont(new Font("Arial", Font.BOLD, 24));
        titulo.setForeground(new Color(255, 140, 0));
        this.add(titulo, BorderLayout.NORTH);

        JPanel panelCentral = new JPanel(new BorderLayout(10, 10));

        JPanel panelConfig = new JPanel(new GridLayout(3, 2, 10, 10));
        panelConfig.setBorder(new TitledBorder("Configuración del Algoritmo"));

        panelConfig.add(new JLabel("Seleccionar Encuesta:"));
        comboEncuestas = new JComboBox<>();
        comboEncuestas.addActionListener(e -> actualizarEstadoBotones());
        panelConfig.add(comboEncuestas);

        panelConfig.add(new JLabel("Algoritmo:"));
        String[] algos = {"K-Means", "K-Means++", "K-Medoids"};
        comboAlgoritmo = new JComboBox<>(algos);
        panelConfig.add(comboAlgoritmo);

        panelConfig.add(new JLabel("Número de Clusters (k):"));
        JPanel panelK = new JPanel(new BorderLayout(5, 0));
        spinK = new JSpinner(new SpinnerNumberModel(3, 2, 100, 1));
        panelK.add(spinK, BorderLayout.CENTER);

        btnEjecutar = new JButton("EJECUTAR");
        btnEjecutar.setBackground(new Color(255, 228, 181));
        btnEjecutar.setFont(new Font("Arial", Font.BOLD, 12));
        btnEjecutar.addActionListener(e -> ejecutarAlgoritmo());
        panelK.add(btnEjecutar, BorderLayout.EAST);

        panelConfig.add(panelK);
        panelCentral.add(panelConfig, BorderLayout.NORTH);

        JPanel panelResultados = new JPanel(new BorderLayout(5, 5));
        panelResultados.setBorder(new TitledBorder("Resultados"));

        panelMetricas = new JPanel(new FlowLayout(FlowLayout.LEFT));
        panelMetricas.setBackground(new Color(245, 245, 245));
        panelMetricas.setBorder(BorderFactory.createEtchedBorder());
        lblResumenMetricas = new JLabel("Selecciona parámetros y ejecuta para ver métricas.");
        lblResumenMetricas.setFont(new Font("Monospaced", Font.BOLD, 14));
        panelMetricas.add(lblResumenMetricas);
        panelResultados.add(panelMetricas, BorderLayout.NORTH);

        tableModel = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) { return false; }
        };

        // --- TABLA CON TOOLTIP EN CELDAS ---
        tablaResultados = new JTable(tableModel) {
            @Override
            public String getToolTipText(java.awt.event.MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int rowIndex = rowAtPoint(p);
                int colIndex = columnAtPoint(p);
                try {
                    if (rowIndex >= 0 && colIndex >= 0) {
                        Object val = getValueAt(rowIndex, colIndex);
                        if (val != null) {
                            tip = val.toString();
                        }
                    }
                } catch (RuntimeException e1) { }
                return tip;
            }
        };
        // -----------------------------------

        tablaResultados.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        tablaResultados.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                if (evt.getClickCount() == 2) {
                    int row = tablaResultados.rowAtPoint(evt.getPoint());
                    int col = tablaResultados.columnAtPoint(evt.getPoint());
                    if (row >= 0 && col >= 0) {
                        Object valor = tablaResultados.getValueAt(row, col);
                        if (valor != null) verTextoCompleto(valor.toString());
                    }
                }
            }
        });
        JScrollPane scrollTabla = new JScrollPane(tablaResultados);
        panelResultados.add(scrollTabla, BorderLayout.CENTER);
        panelCentral.add(panelResultados, BorderLayout.CENTER);

        JPanel panelBotones = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 10));
        btnGrafica = new JButton("Ver Gráfica 2D");
        btnGrafica.addActionListener(e -> mostrarGrafica());
        btnGrafica.setEnabled(false);

        btnExportarRes = new JButton("Exportar CSV");
        btnExportarRes.addActionListener(e -> exportarResultado());
        btnExportarRes.setEnabled(false);

        btnAccuracy = new JButton("Calcular Accuracy");
        btnAccuracy.addActionListener(e -> calcularAccuracy());
        btnAccuracy.setEnabled(false);

        panelBotones.add(btnGrafica);
        panelBotones.add(btnExportarRes);
        panelBotones.add(btnAccuracy);

        panelCentral.add(panelBotones, BorderLayout.SOUTH);
        this.add(panelCentral, BorderLayout.CENTER);

        JButton btnVolver = new JButton("<< Volver al Menú Principal");
        btnVolver.addActionListener(e -> ctrlPresentacion.cambiarVista(VistaPrincipal.VISTA_MENU));
        JPanel panelSur = new JPanel();
        panelSur.add(btnVolver);
        this.add(panelSur, BorderLayout.SOUTH);

        // --- TOOLTIPS GLOBALES PARA BOTONES Y LABELS ---
        GuiUtils.asignarTooltipsGlobales(this);
    }

    private void recargarComboEncuestas() {
        comboEncuestas.removeAllItems();
        for (String id : ctrlPresentacion.obtenerIdsEncuestas()) {
            comboEncuestas.addItem(id);
        }
        actualizarEstadoBotones();
    }

    private void actualizarEstadoBotones() {
        String idSeleccionado = (String) comboEncuestas.getSelectedItem();
        String idUltimaEjecucion = ctrlPresentacion.getCtrlDominio().getUltimoResultadoEncuestaId();
        boolean resultadosDisponibles = (idSeleccionado != null
                && idUltimaEjecucion != null
                && idSeleccionado.equals(idUltimaEjecucion));

        if (resultadosDisponibles) {
            btnExportarRes.setEnabled(true);
            btnExportarRes.setToolTipText("Guardar los resultados actuales en un archivo CSV.");

            btnAccuracy.setEnabled(true);
            btnAccuracy.setToolTipText("Calcular la precisión comparando con etiquetas reales.");
        } else {
            btnExportarRes.setEnabled(false);
            btnExportarRes.setToolTipText("Deshabilitado: Debes pulsar 'EJECUTAR' primero.");

            btnAccuracy.setEnabled(false);
            btnAccuracy.setToolTipText("Deshabilitado: Debes pulsar 'EJECUTAR' primero.");
        }

        if (idSeleccionado == null) {
            btnGrafica.setEnabled(false);
            btnGrafica.setToolTipText("Selecciona una encuesta.");
            return;
        }

        Cuestionario c = ctrlPresentacion.obtenerEncuesta(idSeleccionado);
        if (c == null) return;

        long numNumericas = c.getPreguntas().stream().filter(p -> p.getTipo() == TipoPregunta.NUMERICA).count();
        long numTexto = c.getPreguntas().stream().filter(p -> p.getTipo() == TipoPregunta.TEXTO).count();
        int total = c.getPreguntas().size();

        boolean estructuraValida = (total == 3 && numNumericas == 2 && numTexto == 1);

        if (!estructuraValida) {
            btnGrafica.setEnabled(false);
            btnGrafica.setToolTipText("Deshabilitado: Requiere 1 Pregunta Texto (ID) y 2 Numéricas.");
        } else if (!resultadosDisponibles) {
            btnGrafica.setEnabled(false);
            btnGrafica.setToolTipText("Deshabilitado: Debes pulsar 'EJECUTAR' primero.");
        } else {
            btnGrafica.setEnabled(true);
            btnGrafica.setToolTipText("Ver gráfica de dispersión 2D");
        }
    }

    private void ejecutarAlgoritmo() {
        String id = (String) comboEncuestas.getSelectedItem();
        if (id == null) {
            JOptionPane.showMessageDialog(this, "Selecciona una encuesta.");
            return;
        }
        String algo = (String) comboAlgoritmo.getSelectedItem();
        int k = (Integer) spinK.getValue();
        lblResumenMetricas.setText("Ejecutando " + algo + "... Por favor espere...");

        Timer t = new Timer(100, ev -> {
            try {
                ctrlPresentacion.ejecutarClustering(id, algo, k);
                ClusterResult res = ctrlPresentacion.getCtrlDominio().getUltimoResultado();
                String resumen = String.format("Algoritmo: %s | Clusters (k): %d | SSE: %.4f | Silhouette: %.4f | Tiempo: %d ms",
                        res.algorithm(), k,
                        ctrlPresentacion.getCtrlDominio().getUltimoSse(),
                        ctrlPresentacion.getCtrlDominio().getUltimoSilhouette(),
                        ctrlPresentacion.getCtrlDominio().getUltimoTiempoMs());

                lblResumenMetricas.setText(resumen);
                lblResumenMetricas.setForeground(new Color(0, 100, 0));
                cargarTablaResultados(id, res);
                actualizarEstadoBotones();
                JOptionPane.showMessageDialog(this, "Clustering finalizado con éxito.");
            } catch (Exception ex) {
                lblResumenMetricas.setText("Error: " + ex.getMessage());
                lblResumenMetricas.setForeground(Color.RED);
                JOptionPane.showMessageDialog(this, "Error: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                actualizarEstadoBotones();
            }
        });
        t.setRepeats(false);
        t.start();
    }

    private void cargarTablaResultados(String idEncuesta, ClusterResult res) {
        tableModel.setRowCount(0);
        tableModel.setColumnCount(0);
        Cuestionario c = ctrlPresentacion.obtenerEncuesta(idEncuesta);
        List<Respuesta> respuestas = ctrlPresentacion.listarRespuestas(idEncuesta);
        List<Pregunta> preguntas = c.getPreguntas();

        tableModel.addColumn("Participante");
        for (Pregunta p : preguntas) tableModel.addColumn(p.getEnunciado());
        tableModel.addColumn("CLUSTER");
        tableModel.addColumn("CENTROIDE");

        tablaResultados.getColumnModel().getColumn(0).setPreferredWidth(100);

        for (Respuesta r : respuestas) {
            Object[] fila = new Object[preguntas.size() + 3];
            fila[0] = r.getIdParticipante();
            for (int i = 0; i < preguntas.size(); i++) {
                fila[i + 1] = formatearValor(r.getValores().get(preguntas.get(i).getId()), preguntas.get(i));
            }
            Integer clusterId = res.assignments().get(r.getIdParticipante());
            if (clusterId != null) {
                fila[preguntas.size() + 1] = "Cluster " + clusterId;
                if (clusterId < res.representatives().size()) {
                    fila[preguntas.size() + 2] = res.representatives().get(clusterId).id();
                } else {
                    fila[preguntas.size() + 2] = "N/A";
                }
            } else {
                fila[preguntas.size() + 1] = "-";
                fila[preguntas.size() + 2] = "-";
            }
            tableModel.addRow(fila);
        }
    }

    private String formatearValor(ValorRespuesta val, Pregunta p) {
        if (val == null) return "";
        try {
            if (p.getTipo() == TipoPregunta.OPCION_UNICA && val instanceof ValorRespuestaOpcionUnica) {
                int idx = ((ValorRespuestaOpcionUnica) val).getIndiceSeleccionado();
                if (idx >= 0 && idx < p.getOpciones().size()) return p.getOpciones().get(idx);
            }
            else if (p.getTipo() == TipoPregunta.OPCION_MULTIPLE && val instanceof ValorRespuestaOpcionMultiple) {
                List<Integer> indices = ((ValorRespuestaOpcionMultiple) val).getIndicesSeleccionados();
                List<String> textos = new ArrayList<>();
                for (int idx : indices) {
                    if (idx >= 0 && idx < p.getOpciones().size()) textos.add(p.getOpciones().get(idx));
                }
                return String.join(", ", textos);
            }
        } catch (Exception e) { return val.toString(); }
        return val.toString();
    }

    private void exportarResultado() {
        JFileChooser fc = new JFileChooser();
        fc.setSelectedFile(new File("clusters.csv"));
        if (fc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            ctrlPresentacion.exportarResultadoClustering(fc.getSelectedFile().getAbsolutePath());
        }
    }

    private void calcularAccuracy() {
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Selecciona CSV de etiquetas reales");
        if (fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                double acc = ctrlPresentacion.calcularAccuracy(fc.getSelectedFile().getAbsolutePath());
                JOptionPane.showMessageDialog(this, String.format("Accuracy: %.2f%%", acc * 100));
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, "Error: " + ex.getMessage());
            }
        }
    }

    private void mostrarGrafica() {
        String idEncuesta = (String) comboEncuestas.getSelectedItem();
        Cuestionario c = ctrlPresentacion.getCtrlDominio().obtener(idEncuesta);

        List<Integer> indicesNumericos = new ArrayList<>();
        List<String> nombresEjes = new ArrayList<>();

        int vectorIndex = 0;
        for(int i=1; i<c.getPreguntas().size(); i++) {
            Pregunta p = c.getPreguntas().get(i);
            if (p.getTipo() == TipoPregunta.NUMERICA) {
                indicesNumericos.add(vectorIndex);
                nombresEjes.add(p.getEnunciado());
                vectorIndex++;
            } else {
                List<String> opts = p.getOpciones();
                int dims = (opts == null || opts.isEmpty()) ? 1 : opts.size();
                vectorIndex += Math.max(1, dims);
            }
        }

        if (indicesNumericos.size() != 2) {
            JOptionPane.showMessageDialog(this, "Error: No se detectaron las 2 dimensiones numéricas correctamente.");
            return;
        }

        List<Vectorizer.Point> puntos = ctrlPresentacion.getPuntosUltimoClustering();
        ClusterResult res = ctrlPresentacion.getCtrlDominio().getUltimoResultado();

        DialogoGrafica dialogo = new DialogoGrafica(SwingUtilities.getWindowAncestor(this),
                nombresEjes.get(0), nombresEjes.get(1),
                indicesNumericos.get(0), indicesNumericos.get(1),
                puntos, res.assignments(), res.representatives());
        dialogo.setVisible(true);
    }

    private void verTextoCompleto(String texto) {
        JTextArea textArea = new JTextArea(texto);
        textArea.setRows(10); textArea.setColumns(50);
        textArea.setLineWrap(true); textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        textArea.setFont(new Font("SansSerif", Font.PLAIN, 14));
        JScrollPane scrollPane = new JScrollPane(textArea);
        JOptionPane.showMessageDialog(this, scrollPane, "Detalle Completo", JOptionPane.INFORMATION_MESSAGE);
    }

    // --- GRÁFICA ---
    private static class DialogoGrafica extends JDialog {
        private final List<Vectorizer.Point> puntos;
        private final Map<String, Integer> assignments;
        private final List<Vectorizer.Point> centros;
        private final String titleX, titleY;
        private final int idxX, idxY;

        public DialogoGrafica(Window owner, String titleX, String titleY, int idxX, int idxY,
                              List<Vectorizer.Point> puntos, Map<String, Integer> assignments,
                              List<Vectorizer.Point> centros) {
            super(owner, "Visualización de Clusters", ModalityType.MODELESS);
            this.titleX = titleX; this.titleY = titleY;
            this.idxX = idxX; this.idxY = idxY;
            this.puntos = puntos;
            this.assignments = assignments;
            this.centros = centros;

            setSize(500, 500);
            setLocationRelativeTo(null);

            JPanel panelDibujo = new JPanel() {
                @Override
                protected void paintComponent(Graphics g) {
                    super.paintComponent(g);
                    if (puntos == null || puntos.isEmpty()) return;

                    Graphics2D g2 = (Graphics2D) g;
                    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                    int w = getWidth();
                    int h = getHeight();
                    int padding = 60;

                    g2.setColor(Color.BLACK);
                    g2.drawLine(padding, h - padding, w - padding, h - padding);
                    g2.drawLine(padding, padding, padding, h - padding);

                    g2.setFont(new Font("Arial", Font.BOLD, 14));
                    g2.drawString(titleX, w / 2 - 20, h - 20);

                    g2.rotate(-Math.PI / 2);
                    g2.drawString(titleY, -h / 2 - 20, 30);
                    g2.rotate(Math.PI / 2);

                    double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
                    double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;

                    List<Vectorizer.Point> todos = new ArrayList<>(puntos);
                    if(centros != null) todos.addAll(centros);

                    for (Vectorizer.Point p : todos) {
                        if (idxX < p.values().length && idxY < p.values().length) {
                            double valX = p.values()[idxX];
                            double valY = p.values()[idxY];
                            if (valX < minX) minX = valX;
                            if (valX > maxX) maxX = valX;
                            if (valY < minY) minY = valY;
                            if (valY > maxY) maxY = valY;
                        }
                    }

                    if (maxX == minX) { maxX += 0.5; minX -= 0.5; }
                    if (maxY == minY) { maxY += 0.5; minY -= 0.5; }

                    double rangeX = maxX - minX;
                    double rangeY = maxY - minY;
                    minX -= rangeX * 0.1; maxX += rangeX * 0.1;
                    minY -= rangeY * 0.1; maxY += rangeY * 0.1;

                    Color[] colores = {Color.RED, Color.BLUE, Color.GREEN, Color.MAGENTA, Color.ORANGE, Color.CYAN, Color.PINK, Color.DARK_GRAY};

                    for (Vectorizer.Point p : puntos) {
                        if (idxX >= p.values().length || idxY >= p.values().length) continue;

                        int clusterId = assignments.getOrDefault(p.id(), -1);
                        Color c = (clusterId >= 0 && clusterId < colores.length) ? colores[clusterId] : Color.LIGHT_GRAY;

                        double valX = p.values()[idxX];
                        double valY = p.values()[idxY];

                        int x = padding + (int) ((valX - minX) / (maxX - minX) * (w - 2 * padding));
                        int y = (h - padding) - (int) ((valY - minY) / (maxY - minY) * (h - 2 * padding));

                        int r = 8;
                        g2.setColor(c);
                        g2.setStroke(new BasicStroke(1.5f));
                        g2.drawOval(x - r/2, y - r/2, r, r);
                    }

                    if (centros != null) {
                        for (int i = 0; i < centros.size(); i++) {
                            Vectorizer.Point centro = centros.get(i);
                            if (idxX >= centro.values().length || idxY >= centro.values().length) continue;

                            Color c = (i >= 0 && i < colores.length) ? colores[i] : Color.BLACK;

                            double valX = centro.values()[idxX];
                            double valY = centro.values()[idxY];

                            int x = padding + (int) ((valX - minX) / (maxX - minX) * (w - 2 * padding));
                            int y = (h - padding) - (int) ((valY - minY) / (maxY - minY) * (h - 2 * padding));

                            int r = 14;
                            g2.setColor(c);
                            g2.fillOval(x - r/2, y - r/2, r, r);
                            g2.setColor(Color.BLACK);
                            g2.setStroke(new BasicStroke(1f));
                            g2.drawOval(x - r/2, y - r/2, r, r);
                        }
                    }
                }
            };
            panelDibujo.setBackground(Color.WHITE);
            add(panelDibujo);
        }
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.io.File;
import java.util.List;

public class PanelDatos extends JPanel {

    private CtrlPresentacion ctrlPresentacion;

    public PanelDatos(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        inicializarComponentes();
    }

    private void inicializarComponentes() {
        this.setLayout(new BorderLayout());
        this.setBorder(new EmptyBorder(20, 20, 20, 20));

        // Título superior
        JLabel titulo = new JLabel("Gestor de Datos", SwingConstants.CENTER);
        titulo.setFont(new Font("Arial", Font.BOLD, 24));
        this.add(titulo, BorderLayout.NORTH);

        // Panel central con botones
        JPanel panelCentral = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(10, 10, 10, 10);
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.fill = GridBagConstraints.HORIZONTAL;

        // Botón importar
        JButton btnImportar = new JButton("Importar Encuesta (CSV)");
        btnImportar.setFont(new Font("Arial", Font.PLAIN, 16));
        btnImportar.setBackground(new Color(221, 160, 221)); // Violeta
        btnImportar.setPreferredSize(new Dimension(300, 50));
        btnImportar.addActionListener(e -> abrirSelectorImportar());

        // Botón exportar
        JButton btnExportar = new JButton("Exportar Encuesta (CSV)");
        btnExportar.setFont(new Font("Arial", Font.PLAIN, 16));
        btnExportar.setPreferredSize(new Dimension(300, 50));
        btnExportar.addActionListener(e -> abrirSelectorExportar());

        panelCentral.add(btnImportar, gbc);
        gbc.gridy++;
        panelCentral.add(btnExportar, gbc);

        this.add(panelCentral, BorderLayout.CENTER);

        // Botón volver
        JButton btnVolver = new JButton("<< Volver al Menú Principal");
        btnVolver.addActionListener(e -> ctrlPresentacion.cambiarVista(VistaPrincipal.VISTA_MENU));

        JPanel panelSur = new JPanel();
        panelSur.add(btnVolver);
        this.add(panelSur, BorderLayout.SOUTH);

        //tooltip
        GuiUtils.asignarTooltipsGlobales(this);
    }

    private void abrirSelectorImportar() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setCurrentDirectory(new File("."));
        fileChooser.setDialogTitle("Importar CSV");
        fileChooser.setFileFilter(new FileNameExtensionFilter("Archivos CSV", "csv"));

        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            ctrlPresentacion.importarEncuesta(fileChooser.getSelectedFile().getAbsolutePath());
        }
    }

    // Exportar con selección
    private void abrirSelectorExportar() {
        // Lista de encuestas
        List<String> idsEncuestas = ctrlPresentacion.obtenerIdsEncuestas();

        if (idsEncuestas.isEmpty()) {
            JOptionPane.showMessageDialog(this,
                    "No hay encuestas cargadas en el sistema para exportar.",
                    "Error", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Elegir encuesta
        String idSeleccionado = (String) JOptionPane.showInputDialog(
                this,
                "Selecciona la encuesta que quieres exportar:",
                "Elegir Encuesta",
                JOptionPane.QUESTION_MESSAGE,
                null,
                idsEncuestas.toArray(), // Opciones
                idsEncuestas.get(0));   // Default

        if (idSeleccionado == null) return;

        // Selector de archivo
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setCurrentDirectory(new File("."));
        fileChooser.setDialogTitle("Guardar CSV de '" + idSeleccionado + "'");
        fileChooser.setFileFilter(new FileNameExtensionFilter("Archivos CSV", "csv"));

        // Nombre por defecto
        fileChooser.setSelectedFile(new File(idSeleccionado + "_export.csv"));

        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            String path = file.getAbsolutePath();
            if (!path.toLowerCase().endsWith(".csv")) {
                path += ".csv";
            }
            // Exportar
            ctrlPresentacion.exportarDatos(idSeleccionado, path);
        }
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.domain.classes.model.*;
import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DialogoResponder extends JDialog {

    private final CtrlPresentacion ctrlPresentacion;
    private JComboBox<String> comboEncuestas;
    private JPanel panelPreguntas;

    // Guardamos la referencia a la Pregunta original y a su componente visual
    private Map<Pregunta, InputComponent> inputsMap;

    public DialogoResponder(Frame owner, CtrlPresentacion ctrl) {
        super(owner, "Responder Encuesta", true);
        this.ctrlPresentacion = ctrl;
        this.inputsMap = new HashMap<>();

        this.setSize(600, 500);

        // Aseguramos que no se salga de la pantalla obteniendo el tamaño real
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        if (this.getHeight() > screenSize.height) {
            this.setSize(this.getWidth(), screenSize.height - 50);
        }

        this.setLocationRelativeTo(owner); // Centrar en pantalla
        this.setLayout(new BorderLayout());

        inicializarComponentes();
    }

    private void inicializarComponentes() {
        // --- NORTE: Selector ---
        JPanel panelTop = new JPanel(new FlowLayout(FlowLayout.LEFT));
        panelTop.setBorder(new EmptyBorder(10, 10, 10, 10));
        panelTop.setBackground(new Color(245, 245, 245));
        panelTop.add(new JLabel("Selecciona Encuesta a responder:"));

        comboEncuestas = new JComboBox<>();
        cargarTodasLasEncuestas();
        comboEncuestas.addActionListener(e -> cargarPreguntasDeEncuesta());

        panelTop.add(comboEncuestas);
        add(panelTop, BorderLayout.NORTH);

        // --- CENTRO: Preguntas ---
        panelPreguntas = new JPanel();
        panelPreguntas.setLayout(new BoxLayout(panelPreguntas, BoxLayout.Y_AXIS));
        JScrollPane scroll = new JScrollPane(panelPreguntas);
        scroll.getVerticalScrollBar().setUnitIncrement(16);
        add(scroll, BorderLayout.CENTER);

        // --- SUR: Botones ---
        JPanel panelBotones = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton btnCancelar = new JButton("Cancelar");
        btnCancelar.addActionListener(e -> dispose());

        JButton btnEnviar = new JButton("Enviar Respuesta");
        btnEnviar.setBackground(new Color(100, 149, 237));
        btnEnviar.setForeground(Color.WHITE);
        btnEnviar.setFont(new Font("Arial", Font.BOLD, 12));
        btnEnviar.addActionListener(e -> enviarRespuesta());

        panelBotones.add(btnCancelar);
        panelBotones.add(btnEnviar);
        add(panelBotones, BorderLayout.SOUTH);

        // Estado inicial
        comboEncuestas.setSelectedIndex(-1);
        panelPreguntas.removeAll();
    }

    private void cargarTodasLasEncuestas() {
        comboEncuestas.removeAllItems();
        List<String> todas = ctrlPresentacion.obtenerIdsTodasEncuestas();
        for (String id : todas) {
            comboEncuestas.addItem(id);
        }
    }

    private void cargarPreguntasDeEncuesta() {
        panelPreguntas.removeAll();
        inputsMap.clear();

        String idEncuesta = (String) comboEncuestas.getSelectedItem();
        if (idEncuesta == null) {
            panelPreguntas.revalidate();
            panelPreguntas.repaint();
            return;
        }

        Cuestionario c = ctrlPresentacion.obtenerEncuesta(idEncuesta);
        if (c != null) {
            for (Pregunta p : c.getPreguntas()) {
                agregarPreguntaVisual(p);
            }
        }

        panelPreguntas.revalidate();
        panelPreguntas.repaint();
    }

    private void agregarPreguntaVisual(Pregunta p) {
        JPanel pRow = new JPanel(new BorderLayout());
        pRow.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(10, 10, 10, 10),
                BorderFactory.createMatteBorder(0, 0, 1, 0, Color.LIGHT_GRAY)
        ));

        // 1. Texto de ayuda según el tipo (Requisito del usuario)
        String textoAyuda = obtenerTextoAyuda(p);

        JLabel lbl = new JLabel("<html><b>" + p.getEnunciado() + "</b> <i style='color:gray'>" + textoAyuda + "</i></html>");
        pRow.add(lbl, BorderLayout.NORTH);

        // 2. Componente de entrada
        InputComponent input = crearInputSegunTipo(p);
        pRow.add(input.getComponent(), BorderLayout.CENTER);

        inputsMap.put(p, input); // Guardamos usando la Pregunta como clave
        panelPreguntas.add(pRow);
    }

    private String obtenerTextoAyuda(Pregunta p) {
        switch (p.getTipo()) {
            case NUMERICA: return "(Numérica)";
            case TEXTO: return "(Texto Libre)";
            case OPCION_UNICA: return "(Escoge 1 opción)";
            case OPCION_MULTIPLE:
                int max = p.getMaxSeleccion();
                return "(Escoge varias" + (max > 0 ? ", máx " + max : "") + ")";
            default: return "";
        }
    }

    private InputComponent crearInputSegunTipo(Pregunta p) {
        TipoPregunta tipo = p.getTipo();

        if (tipo == TipoPregunta.OPCION_UNICA) {
            return new RadioInput(p.getOpciones());
        } else if (tipo == TipoPregunta.OPCION_MULTIPLE) {
            return new CheckboxInput(p.getOpciones(), p.getMaxSeleccion());
        } else {
            return new TextInput(tipo == TipoPregunta.NUMERICA);
        }
    }

    private void enviarRespuesta() {
        String idEncuesta = (String) comboEncuestas.getSelectedItem();
        if (idEncuesta == null) return;

        try {
            String usuario = ctrlPresentacion.getUsuarioEmail();
            Respuesta nuevaRespuesta = new Respuesta(usuario);

            // Lista para acumular errores
            List<String> errores = new ArrayList<>();

            // Iteramos sobre las preguntas y sus inputs
            for (Map.Entry<Pregunta, InputComponent> entry : inputsMap.entrySet()) {
                Pregunta p = entry.getKey();
                InputComponent input = entry.getValue();

                try {
                    // Validamos y obtenemos valor
                    ValorRespuesta valor = input.getValorValidado();

                    if (valor != null) {
                        nuevaRespuesta.put(p.getId(), valor);
                    }
                    // Si todo va bien, restauramos color blanco
                    input.marcarComoValido();

                } catch (Exception ex) {
                    // Si falla la validación
                    errores.add("- Pregunta '" + p.getId() + "' (" + p.getEnunciado() + "): " + ex.getMessage());
                    input.marcarComoInvalido(); // Se pone rojo
                }
            }

            if (!errores.isEmpty()) {
                String msg = "No se puede enviar la respuesta. Corrige los siguientes errores:\n\n" + String.join("\n", errores);
                JOptionPane.showMessageDialog(this, msg, "Errores de Validación", JOptionPane.ERROR_MESSAGE);
                return; // IMPORTANTE: No enviamos nada
            }

            // Si llegamos aquí, todo está perfecto
            ctrlPresentacion.agregarRespuesta(idEncuesta, nuevaRespuesta);
            JOptionPane.showMessageDialog(this, "¡Respuesta guardada correctamente!");
            dispose();

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "Error crítico: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    // =======================================================
    // Clases internas (UI + Lógica de Validación)
    // =======================================================

    interface InputComponent {
        JComponent getComponent();
        ValorRespuesta getValorValidado() throws Exception;
        void marcarComoValido();
        void marcarComoInvalido();
    }

    // 1. TEXTO Y NÚMEROS
    class TextInput implements InputComponent {
        JTextField txt;
        boolean esNumerica;

        public TextInput(boolean esNumerica) {
            this.txt = new JTextField();
            this.esNumerica = esNumerica;
        }
        @Override
        public JComponent getComponent() { return txt; }

        @Override
        public void marcarComoValido() { txt.setBackground(Color.WHITE); }

        @Override
        public void marcarComoInvalido() { txt.setBackground(new Color(255, 200, 200)); } // Rojo suave

        @Override
        public ValorRespuesta getValorValidado() throws Exception {
            String t = txt.getText().trim();
            if (t.isEmpty()) return null; // Campo vacío se permite (o lanza excepción si fuera obligatorio)

            if (esNumerica) {
                try {
                    double v = Double.parseDouble(t);
                    return new ValorRespuestaNumerica(v);
                } catch (NumberFormatException e) {
                    throw new Exception("Debe ser un valor numérico.");
                }
            } else {
                return new ValorRespuestaTextual(t);
            }
        }
    }

    // 2. OPCIÓN ÚNICA (Radio Buttons)
    class RadioInput implements InputComponent {
        JPanel panel;
        List<JRadioButton> radios = new ArrayList<>();
        ButtonGroup group = new ButtonGroup();

        public RadioInput(List<String> opciones) {
            panel = new JPanel(new GridLayout(0, 1));
            for (String op : opciones) {
                JRadioButton rb = new JRadioButton(op);
                group.add(rb);
                panel.add(rb);
                radios.add(rb);
            }
        }
        @Override
        public JComponent getComponent() { return panel; }

        @Override
        public void marcarComoValido() { panel.setBackground(null); }
        @Override
        public void marcarComoInvalido() { panel.setBackground(new Color(255, 200, 200)); }

        @Override
        public ValorRespuesta getValorValidado() {
            for (int i = 0; i < radios.size(); i++) {
                if (radios.get(i).isSelected()) {
                    return new ValorRespuestaOpcionUnica(i);
                }
            }
            return null;
        }
    }

    // 3. OPCIÓN MÚLTIPLE (CheckBoxes)
    class CheckboxInput implements InputComponent {
        JPanel panel;
        List<JCheckBox> checks = new ArrayList<>();
        int maxSel;

        public CheckboxInput(List<String> opciones, int maxSel) {
            this.maxSel = maxSel;
            panel = new JPanel(new GridLayout(0, 1));
            for (String op : opciones) {
                JCheckBox cb = new JCheckBox(op);
                panel.add(cb);
                checks.add(cb);
            }
        }
        @Override
        public JComponent getComponent() { return panel; }

        @Override
        public void marcarComoValido() { panel.setBackground(null); }
        @Override
        public void marcarComoInvalido() { panel.setBackground(new Color(255, 200, 200)); }

        @Override
        public ValorRespuesta getValorValidado() throws Exception {
            List<Integer> seleccionadas = new ArrayList<>();
            for (int i = 0; i < checks.size(); i++) {
                if (checks.get(i).isSelected()) {
                    seleccionadas.add(i);
                }
            }

            if (maxSel > 0 && seleccionadas.size() > maxSel) {
                throw new Exception("Has seleccionado " + seleccionadas.size() + " opciones. Máximo permitido: " + maxSel);
            }

            if (seleccionadas.isEmpty()) return null;
            return new ValorRespuestaOpcionMultiple(seleccionadas);
        }
    }
}package edu.upc.prop.presentation.classes;

import edu.upc.prop.presentation.controllers.CtrlPresentacion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;

public class PanelLogin extends JPanel {

    private CtrlPresentacion ctrlPresentacion;

    // Contenedor interno para alternar entre Login y Registro
    private JPanel cards;
    private CardLayout cardLayout;

    // --- Componentes Login ---
    private JTextField txtLoginEmail;
    private JPasswordField txtLoginPass;

    // --- Componentes Registro ---
    private JTextField txtRegNombre;
    private JTextField txtRegApellido;
    private JTextField txtRegEmail;
    private JTextField txtRegNacimiento; // Formato DD/MM/AAAA
    private JPasswordField txtRegPass;
    private JPasswordField txtRegPassRepetir;

    public PanelLogin(CtrlPresentacion ctrlPresentacion) {
        this.ctrlPresentacion = ctrlPresentacion;
        inicializarUI();
    }

    private void inicializarUI() {
        // Usamos GridBagLayout en el panel principal para CENTRAR la caja de login en la pantalla
        this.setLayout(new GridBagLayout());
        this.setBackground(new Color(230, 240, 250)); // Fondo azul muy suave

        // Configuración del CardLayout para cambiar entre formularios
        cardLayout = new CardLayout();
        cards = new JPanel(cardLayout);
        cards.setBorder(BorderFactory.createLineBorder(new Color(180, 180, 180), 1)); // Borde gris fino

        // Añadimos las dos vistas
        cards.add(crearVistaLogin(), "LOGIN");
        cards.add(crearVistaRegistro(), "REGISTRO");

        // Añadimos el panel de cartas al centro de este panel
        this.add(cards);

        //Tooltip
        GuiUtils.asignarTooltipsGlobales(this);
    }

    private JPanel crearVistaLogin() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(Color.WHITE);
        panel.setBorder(new EmptyBorder(30, 40, 30, 40)); // Margen interior

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(10, 5, 10, 5); // Espaciado entre elementos
        gbc.fill = GridBagConstraints.HORIZONTAL;

        // Título
        JLabel lblTitulo = new JLabel("Bienvenido", SwingConstants.CENTER);
        lblTitulo.setFont(new Font("Segoe UI", Font.BOLD, 28));
        lblTitulo.setForeground(new Color(50, 50, 50));
        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        panel.add(lblTitulo, gbc);

        // Campo Email
        gbc.gridy++; gbc.gridwidth = 1;
        panel.add(new JLabel("Correo Electrónico:"), gbc);

        gbc.gridy++;
        txtLoginEmail = new JTextField(20);
        panel.add(txtLoginEmail, gbc);

        // Campo Password
        gbc.gridy++;
        panel.add(new JLabel("Contraseña:"), gbc);

        gbc.gridy++;
        txtLoginPass = new JPasswordField(20);
        panel.add(txtLoginPass, gbc);

        // Botón Entrar
        gbc.gridy++; gbc.insets = new Insets(20, 5, 10, 5);
        JButton btnEntrar = new JButton("INICIAR SESIÓN");
        btnEntrar.setBackground(new Color(70, 130, 180)); // Azul acero
        btnEntrar.setForeground(Color.WHITE);
        btnEntrar.setFont(new Font("Segoe UI", Font.BOLD, 14));
        btnEntrar.setFocusPainted(false);
        btnEntrar.addActionListener(this::actionLogin);
        panel.add(btnEntrar, gbc);

        // Separador
        gbc.gridy++;
        panel.add(new JSeparator(), gbc);

        // Botón Crear Cuenta
        gbc.gridy++; gbc.insets = new Insets(5, 5, 5, 5);
        JButton btnIrRegistro = new JButton("¿No tienes cuenta? Regístrate aquí");
        btnIrRegistro.setBorderPainted(false);
        btnIrRegistro.setContentAreaFilled(false);
        btnIrRegistro.setForeground(new Color(30, 144, 255));
        btnIrRegistro.setCursor(new Cursor(Cursor.HAND_CURSOR));
        btnIrRegistro.addActionListener(e -> {
            limpiarCamposRegistro();
            cardLayout.show(cards, "REGISTRO");
        });
        panel.add(btnIrRegistro, gbc);

        return panel;
    }

    private JPanel crearVistaRegistro() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(Color.WHITE);
        panel.setBorder(new EmptyBorder(20, 40, 20, 40));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.fill = GridBagConstraints.HORIZONTAL;

        // Título
        JLabel lblTitulo = new JLabel("Crear Cuenta Nueva", SwingConstants.CENTER);
        lblTitulo.setFont(new Font("Segoe UI", Font.BOLD, 22));
        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        panel.add(lblTitulo, gbc);

        // Campos
        gbc.gridwidth = 1;

        gbc.gridy++; panel.add(new JLabel("Nombre:"), gbc);
        gbc.gridx = 1; txtRegNombre = new JTextField(15); panel.add(txtRegNombre, gbc);

        gbc.gridx = 0; gbc.gridy++; panel.add(new JLabel("Apellido:"), gbc);
        gbc.gridx = 1; txtRegApellido = new JTextField(15); panel.add(txtRegApellido, gbc);

        gbc.gridx = 0; gbc.gridy++; panel.add(new JLabel("Email:"), gbc);
        gbc.gridx = 1; txtRegEmail = new JTextField(15); panel.add(txtRegEmail, gbc);

        gbc.gridx = 0; gbc.gridy++; panel.add(new JLabel("Fecha Nacimiento (DD/MM/AAAA):"), gbc);
        gbc.gridx = 1; txtRegNacimiento = new JTextField(15); panel.add(txtRegNacimiento, gbc);

        gbc.gridx = 0; gbc.gridy++; panel.add(new JLabel("Contraseña:"), gbc);
        gbc.gridx = 1; txtRegPass = new JPasswordField(15); panel.add(txtRegPass, gbc);

        gbc.gridx = 0; gbc.gridy++; panel.add(new JLabel("Repetir Contraseña:"), gbc);
        gbc.gridx = 1; txtRegPassRepetir = new JPasswordField(15); panel.add(txtRegPassRepetir, gbc);

        // Botón Registrar
        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 2; gbc.insets = new Insets(20, 5, 5, 5);
        JButton btnRegistrar = new JButton("CREAR CUENTA");
        btnRegistrar.setBackground(new Color(60, 179, 113)); // Verde medio
        btnRegistrar.setForeground(Color.WHITE);
        btnRegistrar.setFont(new Font("Segoe UI", Font.BOLD, 14));
        btnRegistrar.setFocusPainted(false);
        btnRegistrar.addActionListener(this::actionRegistrar);
        panel.add(btnRegistrar, gbc);

        // Botón Volver
        gbc.gridy++; gbc.insets = new Insets(5, 5, 5, 5);
        JButton btnVolver = new JButton("Cancelar y Volver");
        btnVolver.addActionListener(e -> cardLayout.show(cards, "LOGIN"));
        panel.add(btnVolver, gbc);

        return panel;
    }

    //LÓGICA DE EVENTOS

    private void actionLogin(ActionEvent e) {
        String email = txtLoginEmail.getText().trim();
        String pass = new String(txtLoginPass.getPassword());

        if (email.isEmpty() || pass.isEmpty()) {
            mostrarError("Por favor, introduce email y contraseña.");
            return;
        }

        // Llamada al controlador de presentación (que delegará al dominio)
        boolean exito = ctrlPresentacion.login(email, pass);

        if (exito) {
            // Limpiamos campos por seguridad
            txtLoginPass.setText("");
        } else {
            mostrarError("Email o contraseña incorrectos.");
        }
    }

    private void actionRegistrar(ActionEvent e) {
        String nombre = txtRegNombre.getText().trim();
        String apellido = txtRegApellido.getText().trim();
        String email = txtRegEmail.getText().trim();
        String nacimiento = txtRegNacimiento.getText().trim();
        String p1 = new String(txtRegPass.getPassword());
        String p2 = new String(txtRegPassRepetir.getPassword());

        if (nombre.isEmpty() || apellido.isEmpty() || email.isEmpty() || p1.isEmpty()) {
            mostrarError("Todos los campos son obligatorios.");
            return;
        }
        if (!p1.equals(p2)) {
            mostrarError("Las contraseñas no coinciden.");
            return;
        }

        try {
            // Llamada al controlador de presentación
            ctrlPresentacion.registrarUsuario(email, p1, nombre, apellido, nacimiento);

            JOptionPane.showMessageDialog(this, "Cuenta creada con éxito. Ahora puedes iniciar sesión.");
            cardLayout.show(cards, "LOGIN"); // Volver al login

        } catch (IllegalArgumentException ex) {
            mostrarError(ex.getMessage()); // E.j. "El usuario ya existe"
        }
    }

    private void limpiarCamposRegistro() {
        txtRegNombre.setText("");
        txtRegApellido.setText("");
        txtRegEmail.setText("");
        txtRegNacimiento.setText("");
        txtRegPass.setText("");
        txtRegPassRepetir.setText("");
    }

    private void mostrarError(String msg) {
        JOptionPane.showMessageDialog(this, msg, "Error", JOptionPane.ERROR_MESSAGE);
    }
}package edu.upc.prop.presentation.controllers;

import edu.upc.prop.domain.controllers.CtrlDominio;
import edu.upc.prop.presentation.classes.VistaPrincipal;

// Imports de Modelo y Utilidades
import edu.upc.prop.domain.classes.clustering.ClusterResult;
import edu.upc.prop.domain.classes.evaluation.ClusteringAccuracy;
import edu.upc.prop.domain.classes.impexp.CsvClusterExporter;
import edu.upc.prop.domain.classes.impexp.CsvSurveyImporter;
import edu.upc.prop.domain.classes.impexp.CsvSurveyExporter;
import edu.upc.prop.domain.classes.model.Cuestionario;
import edu.upc.prop.domain.classes.model.Respuesta;
import edu.upc.prop.domain.classes.vector.Vectorizer;

import java.nio.file.Path;
import java.io.File;
import java.util.List;
import java.util.stream.Collectors;

public class CtrlPresentacion {

    private final CtrlDominio ctrlDominio;
    private final VistaPrincipal vistaPrincipal;

    private String currentSurveyId;

    public CtrlPresentacion(CtrlDominio ctrlDominio) {
        this.ctrlDominio = ctrlDominio;
        this.vistaPrincipal = new VistaPrincipal(this);
    }

    public void inicializarPresentacion() {
        // Al arrancar, hacemos visible la ventana (que mostrará el Login por defecto)
        vistaPrincipal.hacerVisible();
    }

    // GESTIÓN DE SESIÓN Y USUARIOS (NUEVO)
    public boolean login(String email, String password) {
        // Delegamos al dominio la comprobación
        boolean exito = ctrlDominio.login(email, password);

        if (exito) {
            // Si es correcto, decimos a la vista que cambie al Menú Principal
            vistaPrincipal.entrarAlSistema();
        }
        return exito;
    }

    public void registrarUsuario(String email, String pass, String nombre, String ape, String nac) {
        // Delegamos el registro
        ctrlDominio.registrarUsuario(email, pass, nombre, ape, nac);
    }

    public void logout() {
        // Cerramos sesión en dominio y volvemos a la pantalla de Login
        ctrlDominio.logout();
        vistaPrincipal.salirAlLogin();
    }

    public String getUsuarioNombre() {
        return ctrlDominio.getUsuarioLogueadoNombre();
    }

    // NAVEGACIÓN
    public void cambiarVista(String nombreVista) {
        vistaPrincipal.mostrarPanel(nombreVista);
    }

    public CtrlDominio getCtrlDominio() {
        return ctrlDominio;
    }

    // GESTIÓN DE DATOS (ENCUESTAS)
    //Devuelve SOLO las encuestas del usuario logueado.
    public List<String> obtenerIdsMisEncuestas() {
        return ctrlDominio.listarMisEncuestas().stream()
                .map(Cuestionario::getId)
                .collect(Collectors.toList());
    }

    //Devuelve TODAS las encuestas del sistema.
    public List<String> obtenerIdsTodasEncuestas() {
        return ctrlDominio.listar().stream()
                .map(Cuestionario::getId)
                .collect(Collectors.toList());
    }


    public List<String> obtenerIdsEncuestas() {
        return obtenerIdsMisEncuestas();
    }

    //IMPORTAR / EXPORTAR
    public void importarEncuesta(String rutaArchivo) {
        try {
            vistaPrincipal.log("Iniciando importación desde: " + rutaArchivo);
            CsvSurveyImporter importer = new CsvSurveyImporter();
            File f = new File(rutaArchivo);
            String nombreArchivo = f.getName(); // Usar nombre archivo como ID provisional si es necesario

            // Importamos
            CsvSurveyImporter.ImportResult resultado = importer.importSurvey(Path.of(rutaArchivo), nombreArchivo);

            // Guardamos en dominio (CtrlDominio asignará el Owner automáticamente al usuario actual)
            ctrlDominio.guardar(resultado.cuestionario);

            int count = 0;
            for (Respuesta r : resultado.respuestas) {
                ctrlDominio.agregar(resultado.cuestionario.getId(), r);
                count++;
            }

            this.currentSurveyId = resultado.cuestionario.getId();
            vistaPrincipal.log("¡Éxito! Encuesta cargada ID: " + currentSurveyId);
            vistaPrincipal.mostrarInfo("Importación Exitosa", "Se han cargado " + count + " respuestas.\nID asignado: " + currentSurveyId);

        } catch (Exception e) {
            e.printStackTrace();
            vistaPrincipal.log("ERROR Importar: " + e.getMessage());
            vistaPrincipal.mostrarError("Error de Importación", e.getMessage());
        }
    }

    public void exportarDatos(String idEncuesta, String rutaDestino) {
        if (idEncuesta == null || !ctrlDominio.existe(idEncuesta)) {
            vistaPrincipal.mostrarError("Error", "La encuesta seleccionada no existe.");
            return;
        }
        try {
            vistaPrincipal.log("Exportando encuesta '" + idEncuesta + "' a: " + rutaDestino);
            Cuestionario c = ctrlDominio.obtener(idEncuesta);
            List<Respuesta> respuestas = ctrlDominio.listarRespuestas(idEncuesta);

            CsvSurveyExporter exporter = new CsvSurveyExporter();
            exporter.exportSurvey(Path.of(rutaDestino), c, respuestas);

            vistaPrincipal.mostrarInfo("Exportación", "Datos de '" + idEncuesta + "' guardados en:\n" + rutaDestino);
        } catch (Exception e) {
            e.printStackTrace();
            vistaPrincipal.mostrarError("Error de Exportación", e.getMessage());
        }
    }

    // LÓGICA DE CLUSTERING
    public void ejecutarClustering(String idEncuesta, String algoritmo, int k) throws Exception {
        Cuestionario c = ctrlDominio.obtener(idEncuesta);
        if (c == null) throw new Exception("Encuesta no encontrada");
        if (ctrlDominio.getSize(idEncuesta) == 0) throw new Exception("La encuesta no tiene respuestas");

        vistaPrincipal.log("Ejecutando " + algoritmo + " con k=" + k + " sobre " + idEncuesta + "...");

        long t0 = System.currentTimeMillis();
        ClusterResult res = null;

        // Llamamos a los métodos originales del controlador de dominio
        if (algoritmo.equals("K-Means")) {
            res = ctrlDominio.ejecutarKMeans(c, k, false);
        } else if (algoritmo.equals("K-Means++")) {
            res = ctrlDominio.ejecutarKMeans(c, k, true);
        } else {
            res = ctrlDominio.ejecutarKMedoids(c, k);
        }
        long t1 = System.currentTimeMillis();

        vistaPrincipal.log("Fin Clustering. Tiempo: " + (t1 - t0) + "ms");
        vistaPrincipal.log("SSE: " + ctrlDominio.getUltimoSse());
        vistaPrincipal.log("Silhouette: " + ctrlDominio.getUltimoSilhouette());
    }

    public void exportarResultadoClustering(String rutaDestino) {
        ClusterResult res = ctrlDominio.getUltimoResultado();
        String id = ctrlDominio.getUltimoResultadoEncuestaId();

        if (res == null || id == null) {
            vistaPrincipal.mostrarError("Error", "No hay resultados recientes para exportar.");
            return;
        }
        try {
            Cuestionario c = ctrlDominio.obtener(id);
            List<Respuesta> respuestas = ctrlDominio.listarRespuestas(id);
            CsvClusterExporter exporter = new CsvClusterExporter();

            exporter.exportClusterResult(
                    Path.of(rutaDestino),
                    res,
                    ctrlDominio.getUltimoSse(),
                    ctrlDominio.getUltimoSilhouette(),
                    ctrlDominio.getUltimoTiempoMs(),
                    c,
                    respuestas
            );
            vistaPrincipal.mostrarInfo("Exportar Resultado", "Fichero de clusters guardado en:\n" + rutaDestino);
        } catch (Exception e) {
            vistaPrincipal.mostrarError("Error Exportando Clusters", e.getMessage());
        }
    }

    public double calcularAccuracy(String rutaEtiquetas) throws Exception {
        ClusterResult res = ctrlDominio.getUltimoResultado();
        if (res == null) throw new Exception("No hay resultado de clustering calculado.");
        return ClusteringAccuracy.accuracyFromCsv(res, Path.of(rutaEtiquetas));
    }

    public List<Vectorizer.Point> getPuntosUltimoClustering() {
        return ctrlDominio.calcularDatosUltimaEncuesta();
    }

    public Cuestionario obtenerEncuesta(String id) {
        return ctrlDominio.obtener(id);
    }

    public void agregarRespuesta(String idEncuesta, Respuesta r) {
        ctrlDominio.agregar(idEncuesta, r);
    }

    public List<Respuesta> listarRespuestas(String idEncuesta) {
        return ctrlDominio.listarRespuestas(idEncuesta);
    }

    public String getUsuarioEmail() {
        return ctrlDominio.getUsuarioLogueadoEmail();
    }
}

